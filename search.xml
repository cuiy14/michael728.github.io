<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[有趣的博客-整理]]></title>
      <url>%2F2017%2F04%2F25%2Fblog-interesting-list%2F</url>
      <content type="text"><![CDATA[对于整理癖重度患者，必须要整理一下收藏夹中的博客了，有一些博主的博客很用心，下面先简单整理一下好了： 数据挖掘编程技术资源分享生活乐趣]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows下利用批命令修改IP设置]]></title>
      <url>%2F2016%2F11%2F14%2Ftools-batch-file-set-ip-mask-gateway%2F</url>
      <content type="text"><![CDATA[因为在实验室需要将网络设置为自动获取IP地址和DNS服务器地址，然而，在宿舍想要登录成功6维BT站，却需要配置静态IP地址。每次切换IP需要输入一串参数，打开网络适配器去设置，很麻烦，下午就花时间解决了一下。 设置静态IP/DNS地址12netsh int ipv4 set address name="以太网" source=static address=222.26.218.27 mask=255.255.255.40 gateway=222.26.218.254netsh int ipv4 set dns name="以太网" source=static address=202.118.66.66 register=primary validate=no 这里需要注意的是，name这个值，是你电脑网络连接的名称，需要到网络适配器中去查看，示意图如下：大部分name值都是”本地连接”，需要根据你自己的配置修改名称。 ipv4 address:IP地址 mask:子网掩码 gateway:默认网关 dns address:首选DNS服务器 设置动态IP/DNS地址12netsh interface ipv4 set address name="以太网" source=dhcpnetsh interface ipv4 set dnsservers name="以太网" source=dhcp 命令升级版将设置静态IP和动态IP集成到一个bat文件中，方便执行。 注意：执行时，需要管理员权限。123456789101112131415161718192021222324252627282930@echo offtitle 一件切换IP地址--Michael翔color 0a:beginecho 一键切换IP地址echo 1.切换成静态IP（宿舍）echo 2.切换成动态IPecho.@rem echo. 紧跟着一点，效果是空了一行set /p op=Type optionif "%op%"=="1" goto op1if "%op%"=="2" goto op2:op1echo "你选择了选项1"netsh int ipv4 set address name="以太网" source=static address=222.26.218.16 mask=255.255.255.0 gateway=222.26.218.254netsh int ipv4 set dns name="以太网" source=static address=202.118.66.6 register=primary validate=nogoto exit@rem 这里的go to begin不能少，不然，执行选项1之后，会继续向下执行:op2echo "你选择了选项2"netsh interface ipv4 set address name="以太网" source=dhcpnetsh interface ipv4 set dnsservers name="以太网" source=dhcpgoto exit:Exitpasue 注解：在 SET 命令中添加了两个新命令行开关:12SET /A expressionSET /P variable=[promptString] /A 命令行开关指定等号右边的字符串为被评估的数字表达式。 /P 命令行开关允许将变量数值设成用户输入的一行输入。读取输入行之前，显示指定的 promptString。promptString (提示词)可以是空的命令简介 echo+message如果，要在执行bat命令时，让cmd窗口不一闪而过，在文件末尾添加pause就可以了！例如：echo “hello michael翔” @echo off这个效果是不显示后面的执行命令，关闭回显功能； rem注释命令，类似于在C语言中的/——–/，它并不会被执行，只是起一个注释的作用例如：rem 这里是注释哈！不会执行，但是，会显示此行，如果要关闭回显，加符号@； pause暂停命令。 goto跳转命令。程序指针跳转到指定的标签，从标签后的第一条命令开始继续执行批处理程序。例如：123:1startgoto 1 这里就会循环执行，打卡很多窗口。 set显示、设置或删除变量例如：12345set a=2set b=aecho %a%echo %b%pasue 这里是设置b为字符串a，如果要将a值赋值给b，应该b=%a%。set a=删除变量 符号简介 @回显关闭，表示不显示@后面的命令。 命令释义文件夹管理 cd 显示当前目录名或改变当前目录。 md 创建目录。 rd 删除一个目录。 dir 显示目录中的文件和子目录列表。 tree 以图形显示驱动器或路径的文件夹结构。 path 为可执行文件显示或设置一个搜索路径。 copy 复制文件和目录树。 文件管理 type 显示文本文件的内容。 copy 将一份或多份文件复制到另一个位置。 del 删除一个或数个文件。 move 移动文件并重命名文件和目录。（Windows XP Home Edition中没有) ren重命名文件。 replace 替换文件。 attrib 显示或更改文件属性。 find 搜索字符串。 fc 比较两个文件或两个文件集并显示它们之间的不同 参考 百科-批处理 How to script a change to a static IP address or DHCP IP address in Windows using a batch file 批处理常用命令总结和WindowsXP下运行命令使用大全及优化 BAT 批处理脚本 教程 Multiple choices menu on batch file? 知道-批处理中set /a和set /p有什么区别，一般怎么用？谢谢回答！ 贴吧-简述一下怎么自己写批处理吧 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows无法识别USB设备--移动硬盘/U盘 解决方法]]></title>
      <url>%2F2016%2F11%2F08%2Ftools-no-usb%2F</url>
      <content type="text"><![CDATA[今天用了好几年的东芝移动硬盘无法识别，插上Win10之后，硬盘指示灯闪亮了几下之后，就提示“无法识别的USB设备”，询问度娘无果，搜索google，发下了一篇好文，截图如下： PS：做一下说明Win+X，打开“设备管理器”，在通用串行总线控制器中找到大容量存储设备，卸载；同时，将USB Root Hub也卸载，之后重启，发现解决了问题。（是在联想微信公众号的在线工程师帮助下解决的，联想的服务还是很赞的嘛，所以，买笔记本，还是要买大厂的，戴尔家貌似也有此服务） 所有的USB无法识别的问题不一定全是按照这个步骤都能解决，但是，它提供了一些参考！ 后记经过半天的排错，解决了老移动硬盘发生的这个错误，挽救了它的的生命，找回了里边的资料。同时，双十一期间，正好优惠价买了希捷的Backup Plus睿品（升级版） 2T 2.5英寸 USB3.0移动硬盘 皓月银(STDR2000301),感觉还是不错的，做工很好，同时，提供了实时备份的软件，还有200G的OneDrive空间，之前没怎么使用微软家的产品，结果最近体验了OneNote等产品后，发现还是很棒的！尤其是OneDrive可以在线编辑Word等文档！如果想体验一下，可以注册体验：OneDrive 参考 Win10无法识别USB设备（U盘/移动硬盘）怎么办？ 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客建站日志]]></title>
      <url>%2F2016%2F09%2F03%2Fblog-logfile%2F</url>
      <content type="text"><![CDATA[建站日志 2016-09-03：优化了sitemap 、添加了博客内搜索2016-09-03：增加了工具页面http://michaelxiang.me/tools/，激动人心2017-04-03: 修改了工具总结，添加了几个这段时间发现的好软件2017-04-22：将博客评论由多说变为disqus，尽管需要FQ才能看到，但是没办法，多说要关闭了…… 参考Hexo+nexT主题搭建个人博客hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌） 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python正则表达式学习摘要及资料]]></title>
      <url>%2F2016%2F07%2F28%2Fpython-regx%2F</url>
      <content type="text"><![CDATA[摘要 在正则表达式中，如果直接给出字符，就是精确匹配。 {m,n}? 对于前一个字符重复 m到 n 次，并且取尽可能少的情况 在字符串&#39;aaaaaa&#39;中，a{2,4} 会匹配 4 个 a，但 a{2,4}? 只匹配 2 个 a。^表示行的开头，^\d表示必须以数字开头。 $表示行的结束，\d$表示必须以数字结束。 你可能注意到了，py也可以匹配&#39;python&#39;–&gt;py;但是加上^py$就变成了整行匹配，就只能匹配’py’了,匹配&#39;python&#39;时，就什么也得不到。 参考表正则表达式特殊序列 re模块re.compile(pattern[, flags])把正则表达式的模式和标识转化成正则表达式对象，供match() 和search() 这两个函数使用。 re 所定义的 flag 包括：123456re.I 忽略大小写re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境re.M 多行模式re.S 即为’ . ’并且包括换行符在内的任意字符（’ . ’不包括换行符）re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库re.X 为了增加可读性，忽略空格和’ # ’后面的注释 以下两种用法结果相同：(A)12compiled_pattern = re.compile(pattern) result = compiled_pattern.match(string) (B)1result = re.match(pattern, string) 由于Python的字符串本身也用\转义，所以要特别注意：123s = 'ABC\\-001' # Python的字符串 #对应的正则表达式字符串变成： #'ABC\-001' 因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了123s = r'ABC\-001' # Python的字符串# 对应的正则表达式字符串不变：# 'ABC\-001' searchre.search(pattern, string[, flags])在字符串中查找匹配正则表达式模式的位置，返回 MatchObject 的实例，如果没有找到匹配的位置，则返回None。 对于已编译的正则表达式对象来说（re.RegexObject），有以下search 的方法：search (string[, pos[, endpos]])若 regex 是已编译好的正则表达式对象，regex.search(string, 0, 50) 等同于regex.search(string[:50], 0)`。123&gt;&gt;&gt; pattern = re.compile("a") &gt;&gt;&gt; pattern.search("abcde") # Match at index 0 &gt;&gt;&gt; pattern.search("abcde", 1) # No match; matchre.match(pattern, string[, flags])判断 pattern 是否在字符串开头位置匹配。对于 RegexObject，有：match(string[, pos[, endpos]])match() 函数只在字符串的开始位置尝试匹配正则表达式，也就是只报告从位置 0 开始的匹配情况，而 search() 函数是扫描整个字符串来查找匹配。如果想要搜索整个字符串来寻找匹配，应当用 search()。12&gt;&gt;&gt; pattern.match('bca',2).group()'a' 虽然，match默认是从开头匹配，但是，如果指定位置，仍然能成功；但是！match也是从指定位置开始匹配，不匹配仍然会失败，这一点就和search有区别啦。 match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。12345test = '用户输入的字符串'if re.match(r'正则表达式', test): print('ok')else: print('failed') splitre.split(pattern, string[, maxsplit=0, flags=0])此功能很常用，可以将将字符串匹配正则表达式的部分割开并返回一个列表。对 RegexObject，有函数：split(string[, maxsplit=0]) 对于一个找不到匹配的字符串而言，split 不会对其作出分割 12&gt;&gt;&gt; 'a b c'.split(' ')['a', 'b', '', '', 'c'] 这里用字符串自带的split方法就很不灵活。12&gt;&gt;&gt; re.split(r'\s+', 'a b c')['a', 'b', 'c'] 看出差别了吧，很强大！再来一个终极的：12&gt;&gt;&gt; re.split(r'[\s\,\;]+', 'a,b;; c d')['a', 'b', 'c', 'd'] r&#39;[\s\,\;]+&#39;的正则表达式意思为：空格或者,或者;`出现1次或1次以上都是满足条件的分割符号！所以，最后结果还是很干净。 findallre.findall(pattern, string[, flags]) 在字符串中找到正则表达式所匹配的所有子串，并组成一个列表返回。同样 RegexObject有：findall(string[, pos[, endpos]])1234 #get all content enclosed with [], and return a list &gt;&gt;&gt; pattern=re.compile(r'hh')&gt;&gt;&gt; pattern.findall('hhmichaelhh')['hh', 'hh'] finditerre.finditer(pattern, string[, flags])和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并组成一个迭代器返回。同样 RegexObject 有：finditer(string[, pos[, endpos]]) subre.sub(pattern, repl, string[, count, flags])在字符串 string 中找到匹配正则表达式pattern的所有子串，用另一个字符串 repl进行替换。如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。 返回值是替换后的新字符串。 对于 RegexObject有：sub(repl, string[, count=0])123456789&gt;&gt;&gt; pattern=re.compile(r'\d')&gt;&gt;&gt; pattern.sub('no','12hh34hh')'nonohhnonohh'&gt;&gt;&gt; pattern.sub('no','12hh34hh',0)'nonohhnonohh'&gt;&gt;&gt; pattern.sub('no','12hh34hh',count=0)'nonohhnonohh'&gt;&gt;&gt; pattern.sub('no','12hh34hh',1)'no2hh34hh' 通过上面的例子，可以看出,count是可以缺省的，同时，默认值是0，表示全部替换；否则，就是指定替换几个。 subnre.subn(pattern, repl, string[, count, flags])该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数。同样RegexObject有：subn(repl, string[, count=0])12&gt;&gt;&gt; pattern.subn('no','12hh34hh',count=0)('nonohhnonohh', 4) 分组除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如： ^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：1234567891011&gt;&gt;&gt; m = re.match(r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$', '010-12345')&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;&gt;&gt;&gt; m.group(0)'010-12345'&gt;&gt;&gt; m.group(1)'010'&gt;&gt;&gt; m.group(2)'12345'&gt;&gt;&gt; m.groups()('010', '12345') 通过实验，如果不用括号，得到的Match对象课可以使用例如a.group(0)或者a.group()但是，使用a.group(1)就会报错的。 贪婪匹配正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：12&gt;&gt;&gt; re.match(r'^(\d+)(0*)$', '102300').groups()('102300', '') 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：12&gt;&gt;&gt; re.match(r'^(\d+?)(0*)$', '102300').groups()('1023', '00') SF-正则表达式的贪婪\非贪婪模式怎么理解？ Python正则表达式学习资源 廖雪峰-正则表达式 IBM-使用 Python 模块 re 实现解析小工具 deerchao-则表达式30分钟入门教程 deerchao-正则表达式30分钟入门教程 静觅-爬虫入门七之正则表达式 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在魔都上海的银联实习生活]]></title>
      <url>%2F2016%2F07%2F25%2Flife-about-intern-in-Shanghai%2F</url>
      <content type="text"><![CDATA[不知不觉，来传说中的“魔都”已经一个多月了，然而，我并没有感受到他的魔力，可能是我还没去发现吧……应该是我还没有动力去发现！ 文章开头的图片拍摄于我和媳妇儿2014年“南游”的时候，当时在外滩附近大楼拍的，现在想想，仿佛过去没多久，事实，白驹过隙，已2年多了:)记录一下在银联这段时间的生活： 灯火通明的开发中心大楼 园区风景 伙食真是没话说啊，减肥太难，囧 我们小组现在的办公室，据说马上要搬了，不知道那时候我还在不在 来张我的小窝 陪别人去逛的徐家汇那边的恒隆，确实很繁华！可惜，你不在我身边 这期间，曾经犹豫过，来上海的压力让我很担心将来会不会影响到和我女朋友的感情…… 后来，既来之，则安之，听了你的意见。 离开大连时拍的一张照片，在手机里看到时，很想念，想想就很开心的啊！啊哈哈哈…… 希望一切安好，珍惜拥有的一切，努力变得更好！ 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python--matplotlib绘图可视化知识点整理]]></title>
      <url>%2F2016%2F05%2F14%2Fpython-matplotlib-basic%2F</url>
      <content type="text"><![CDATA[强烈推荐ipython无论你工作在什么项目上，IPython都是值得推荐的。利用ipython --pylab，可以进入PyLab模式，已经导入了matplotlib库与相关软件包（例如Numpy和Scipy)，额可以直接使用相关库的功能。 本文作为学习过程中对matplotlib一些常用知识点的整理，方便查找。 这样IPython配置为使用你所指定的matplotlib GUI后端（TK/wxPython/PyQt/Mac OS X native/GTK)。对于大部分用户而言，默认的后端就已经够用了。Pylab模式还会向IPython引入一大堆模块和函数以提供一种更接近MATLAB的界面。 参考 matplotlib-绘制精美的图表 matplotlib.pyplot.plt参数介绍 12345678import matplotlib.pyplot as pltlabels='frogs','hogs','dogs','logs'sizes=15,20,45,10colors='yellowgreen','gold','lightskyblue','lightcoral'explode=0,0.1,0,0plt.pie(sizes,explode=explode,labels=labels,colors=colors,autopct='%1.1f%%',shadow=True,startangle=50)plt.axis('equal')plt.show() matplotlib图标正常显示中文为了在图表中能够显示中文和负号等，需要下面一段设置：123import matplotlib.pyplot as pltplt.rcParams['font.sas-serig']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 matplotlib inline和pylab inline可以使用ipython --pylab打开ipython命名窗口。 12%matplotlib inline #notebook模式下%pylab inline #ipython模式下 这两个命令都可以在绘图时，将图片内嵌在交互窗口，而不是弹出一个图片窗口，但是，有一个缺陷：除非将代码一次执行，否则，无法叠加绘图，因为在这两种模式下，是要有plt出现，图片会立马show出来，因此： 推荐在ipython notebook时使用，这样就能很方便的一次编辑完代码，绘图。 为项目设置matplotlib参数在代码执行过程中，有两种方式更改参数： 使用参数字典(rcParams) 调用matplotlib.rc()命令 通过传入关键字元祖，修改参数 如果不想每次使用matplotlib时都在代码部分进行配置，可以修改matplotlib的文件参数。可以用matplot.get_config()命令来找到当前用户的配置文件目录。 配置文件包括以下配置项： axex: 设置坐标轴边界和表面的颜色、坐标刻度值大小和网格的显示backend: 设置目标暑促TkAgg和GTKAggfigure: 控制dpi、边界颜色、图形大小、和子区( subplot)设置font: 字体集（font family）、字体大小和样式设置grid: 设置网格颜色和线性legend: 设置图例和其中的文本的显示line: 设置线条（颜色、线型、宽度等）和标记patch: 是填充2D空间的图形对象，如多边形和圆。控制线宽、颜色和抗锯齿设置等。savefig: 可以对保存的图形进行单独设置。例如，设置渲染的文件的背景为白色。verbose: 设置matplotlib在执行期间信息输出，如silent、helpful、debug和debug-annoying。xticks和yticks: 为x,y轴的主刻度和次刻度设置颜色、大小、方向，以及标签大小。 线条相关属性标记设置 用来该表线条的属性 线条风格linestyle或ls 描述 线条风格linestyle或ls 描述 ‘-‘ 实线 ‘:’ 虚线 ‘–’ 破折线 ‘None’,’ ‘,’’ 什么都不画 ‘-.’ 点划线 线条标记 标记maker 描述 标记 描述 ‘o’ 圆圈 ‘.’ 点 ‘D’ 菱形 ‘s’ 正方形 ‘h’ 六边形1 ‘*’ 星号 ‘H’ 六边形2 ‘d’ 小菱形 ‘_’ 水平线 ‘v’ 一角朝下的三角形 ‘8’ 八边形 ‘&lt;’ 一角朝左的三角形 ‘p’ 五边形 ‘&gt;’ 一角朝右的三角形 ‘,’ 像素 ‘^’ 一角朝上的三角形 ‘+’ 加号 ‘\ ‘ 竖线 ‘None’,’’,’ ‘ 无 ‘x’ X 颜色可以通过调用matplotlib.pyplot.colors()得到matplotlib支持的所有颜色。 别名 颜色 别名 颜色 b 蓝色 g 绿色 r 红色 y 黄色 c 青色 k 黑色 m 洋红色 w 白色 如果这两种颜色不够用，还可以通过两种其他方式来定义颜色值： 使用HTML十六进制字符串 color=&#39;eeefff&#39; 使用合法的HTML颜色名字（’red’,’chartreuse’等）。 也可以传入一个归一化到[0,1]的RGB元祖。 color=(0.3,0.3,0.4) 很多方法可以介绍颜色参数，如title()。plt.tilte(&#39;Title in a custom color&#39;,color=&#39;#123456&#39;） 背景色通过向如matplotlib.pyplot.axes()或者matplotlib.pyplot.subplot()这样的方法提供一个axisbg参数，可以指定坐标这的背景色。 subplot(111,axisbg=(0.1843,0.3098,0.3098) 基础如果你向plot()指令提供了一维的数组或列表，那么matplotlib将默认它是一系列的y值，并自动为你生成x的值。默认的x向量从0开始并且具有和y同样的长度，因此x的数据是[0,1,2,3]. 图片来自:绘图: matplotlib核心剖析 确定坐标范围 plt.axis([xmin, xmax, ymin, ymax])上面例子里的axis()命令给定了坐标范围。 xlim(xmin, xmax)和ylim(ymin, ymax)来调整x,y坐标范围123456789101112131415161718%matplotlib inlineimport numpy as npimport matplotlib.pyplot as pltfrom pylab import *x = np.arange(-5.0, 5.0, 0.02)y1 = np.sin(x)plt.figure(1)plt.subplot(211)plt.plot(x, y1)plt.subplot(212)#设置x轴范围xlim(-2.5, 2.5)#设置y轴范围ylim(-1, 1)plt.plot(x, y1) 叠加图用一条指令画多条不同格式的线。123456789import numpy as npimport matplotlib.pyplot as plt# evenly sampled time at 200ms intervalst = np.arange(0., 5., 0.2)# red dashes, blue squares and green trianglesplt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')plt.show() plt.figure()你可以多次使用figure命令来产生多个图，其中，图片号按顺序增加。这里，要注意一个概念当前图和当前坐标。所有绘图操作仅对当前图和当前坐标有效。通常，你并不需要考虑这些事，下面的这个例子为大家演示这一细节。1234567891011121314import matplotlib.pyplot as pltplt.figure(1) # 第一张图plt.subplot(211) # 第一张图中的第一张子图plt.plot([1,2,3])plt.subplot(212) # 第一张图中的第二张子图plt.plot([4,5,6])plt.figure(2) # 第二张图plt.plot([4,5,6]) # 默认创建子图subplot(111)plt.figure(1) # 切换到figure 1 ; 子图subplot(212)仍旧是当前图plt.subplot(211) # 令子图subplot(211)成为figure1的当前图plt.title('Easy as 1,2,3') # 添加subplot 211 的标题 figure感觉就是给图像ID，之后可以索引定位到它。 plt.text()添加文字说明 text()可以在图中的任意位置添加文字，并支持LaTex语法 xlable(), ylable()用于添加x轴和y轴标签 title()用于添加图的题目 12345678910111213141516171819import numpy as npimport matplotlib.pyplot as pltmu, sigma = 100, 15x = mu + sigma * np.random.randn(10000)# 数据的直方图n, bins, patches = plt.hist(x, 50, normed=1, facecolor='g', alpha=0.75)plt.xlabel('Smarts')plt.ylabel('Probability')#添加标题plt.title('Histogram of IQ')#添加文字plt.text(60, .025, r'$\mu=100,\ \sigma=15$')plt.axis([40, 160, 0, 0.03])plt.grid(True)plt.show() text中前两个参数感觉应该是文本出现的坐标位置。 plt.annotate()文本注释在数据可视化的过程中，图片中的文字经常被用来注释图中的一些特征。使用annotate()方法可以很方便地添加此类注释。在使用annotate时，要考虑两个点的坐标：被注释的地方xy(x, y)和插入文本的地方xytext(x, y)。[^1] 123456789101112131415import numpy as npimport matplotlib.pyplot as pltax = plt.subplot(111)t = np.arange(0.0, 5.0, 0.01)s = np.cos(2*np.pi*t)line, = plt.plot(t, s, lw=2)plt.annotate('local max', xy=(2, 1), xytext=(3, 1.5), arrowprops=dict(facecolor='black', shrink=0.05), )plt.ylim(-2,2)plt.show() [^1]:DataHub-Python 数据可视化入门1 plt.xticks()/plt.yticks()设置轴记号现在是明白干嘛用的了，就是人为设置坐标轴的刻度显示的值。 12345678910111213141516171819202122232425262728# 导入 matplotlib 的所有内容（nympy 可以用 np 这个名字来使用）from pylab import *# 创建一个 8 * 6 点（point）的图，并设置分辨率为 80figure(figsize=(8,6), dpi=80)# 创建一个新的 1 * 1 的子图，接下来的图样绘制在其中的第 1 块（也是唯一的一块）subplot(1,1,1)X = np.linspace(-np.pi, np.pi, 256,endpoint=True)C,S = np.cos(X), np.sin(X)# 绘制余弦曲线，使用蓝色的、连续的、宽度为 1 （像素）的线条plot(X, C, color="blue", linewidth=1.0, linestyle="-")# 绘制正弦曲线，使用绿色的、连续的、宽度为 1 （像素）的线条plot(X, S, color="r", lw=4.0, linestyle="-")plt.axis([-4,4,-1.2,1.2])# 设置轴记号xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])yticks([-1, 0, +1], [r'$-1$', r'$0$', r'$+1$'])# 在屏幕上显示show() 当我们设置记号的时候，我们可以同时设置记号的标签。注意这里使用了 LaTeX。[^2] [^2]:Matplotlib 教程 移动脊柱 坐标系1234567ax = gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data',0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0)) 这个地方确实没看懂，囧，以后再说吧，感觉就是移动了坐标轴的位置。 plt.legend()添加图例1234plot(X, C, color="blue", linewidth=2.5, linestyle="-", label="cosine")plot(X, S, color="red", linewidth=2.5, linestyle="-", label="sine")legend(loc='upper left') matplotlib.pyplot使用plt.style.use(&#39;ggplot&#39;)命令，可以作出ggplot风格的图片。 12345678910111213141516171819202122232425# Import necessary packagesimport pandas as pd%matplotlib inlineimport matplotlib.pyplot as pltplt.style.use('ggplot')from sklearn import datasetsfrom sklearn import linear_modelimport numpy as np# Load databoston = datasets.load_boston()yb = boston.target.reshape(-1, 1)Xb = boston['data'][:,5].reshape(-1, 1)# Plot dataplt.scatter(Xb,yb)plt.ylabel('value of house /1000 ($)')plt.xlabel('number of rooms')# Create linear regression objectregr = linear_model.LinearRegression()# Train the model using the training setsregr.fit( Xb, yb)# Plot outputsplt.scatter(Xb, yb, color='black')plt.plot(Xb, regr.predict(Xb), color='blue', linewidth=3)plt.show() 给特殊点做注释好吧，又是注释，多个例子参考一下！ 我们希望在 2π/32π/3 的位置给两条函数曲线加上一个注释。首先，我们在对应的函数图像位置上画一个点；然后，向横轴引一条垂线，以虚线标记；最后，写上标签。1234567891011121314151617t = 2*np.pi/3# 作一条垂直于x轴的线段，由数学知识可知，横坐标一致的两个点就在垂直于坐标轴的直线上了。这两个点是起始点。plot([t,t],[0,np.cos(t)], color ='blue', linewidth=2.5, linestyle="--")scatter([t,],[np.cos(t),], 50, color ='blue')annotate(r'$\sin(\frac&#123;2\pi&#125;&#123;3&#125;)=\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$', xy=(t, np.sin(t)), xycoords='data', xytext=(+10, +30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle="-&gt;", connectionstyle="arc3,rad=.2"))plot([t,t],[0,np.sin(t)], color ='red', linewidth=2.5, linestyle="--")scatter([t,],[np.sin(t),], 50, color ='red')annotate(r'$\cos(\frac&#123;2\pi&#125;&#123;3&#125;)=-\frac&#123;1&#125;&#123;2&#125;$', xy=(t, np.cos(t)), xycoords='data', xytext=(-90, -50), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle="-&gt;", connectionstyle="arc3,rad=.2")) plt.subplot()plt.subplot(2,3,1)表示把图标分割成2*3的网格。也可以简写plt.subplot(231)。其中，第一个参数是行数，第二个参数是列数，第三个参数表示图形的标号。 plt.axes()我们先来看什么是Figure和Axes对象。在matplotlib中，整个图像为一个Figure对象。在Figure对象中可以包含一个，或者多个Axes对象。每个Axes对象都是一个拥有自己坐标系统的绘图区域。其逻辑关系如下^3： plt.axes-官方文档 axes() by itself creates a default full subplot(111) window axis. axes(rect, axisbg=’w’) where rect = [left, bottom, width, height] in normalized (0, 1) units. axisbg is the background color for the axis, default white. axes(h) where h is an axes instance makes h the current axis. An Axes instance is returned. rect=[左, 下, 宽, 高] 规定的矩形区域,rect矩形简写，这里的数值都是以figure大小为比例，因此，若是要两个axes并排显示，那么axes[2]的左=axes[1].左+axes[1].宽，这样axes[2]才不会和axes[1]重叠。 show code:1234567891011121314151617181920212223242526272829303132333435http://matplotlib.org/examples/pylab_examples/axes_demo.htmlimport matplotlib.pyplot as pltimport numpy as np# create some data to use for the plotdt = 0.001t = np.arange(0.0, 10.0, dt)r = np.exp(-t[:1000]/0.05) # impulse responsex = np.random.randn(len(t))s = np.convolve(x, r)[:len(x)]*dt # colored noise# the main axes is subplot(111) by defaultplt.plot(t, s)plt.axis([0, 1, 1.1*np.amin(s), 2*np.amax(s)])plt.xlabel('time (s)')plt.ylabel('current (nA)')plt.title('Gaussian colored noise')# this is an inset axes over the main axesa = plt.axes([.65, .6, .2, .2], axisbg='y')n, bins, patches = plt.hist(s, 400, normed=1)plt.title('Probability')plt.xticks([])plt.yticks([])# this is another inset axes over the main axesa = plt.axes([0.2, 0.6, .2, .2], axisbg='y')plt.plot(t[:len(r)], r)plt.title('Impulse response')plt.xlim(0, 0.2)plt.xticks([])plt.yticks([])plt.show() [^3]:绘图: matplotlib核心剖析 pyplot.pie参数 matplotlib.pyplot.pie colors颜色找出matpltlib.pyplot.plot中的colors可以取哪些值？ so-Named colors in matplotlib CSDN-matplotlib学习之（四）设置线条颜色、形状12for name,hex in matplotlib.colors.cnames.iteritems(): print name,hex 打印颜色值和对应的RGB值。 plt.axis(&#39;equal&#39;)避免比例压缩为椭圆 autopct How do I use matplotlib autopct?1autopct enables you to display the percent value using Python string formatting. For example, if autopct='%.2f', then for each pie wedge, the format string is '%.2f' and the numerical percent value for that wedge is pct, so the wedge label is set to the string '%.2f'%pct. 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL基础语法笔记教程整理]]></title>
      <url>%2F2016%2F05%2F03%2FSQL%2F</url>
      <content type="text"><![CDATA[最近从图书馆借了本介绍SQL的书，打算复习一下基本语法，记录一下笔记，整理一下思路，以备日后复习之用。 PS：本文适用SQL Server2008语法。 一、关系型数据库和SQL实际上准确的讲，SQL是一门语言，而不是一个数据库。 什么是SQL呢？简而言之，SQL就是维护和使用关系型数据库中的的数据的一种标准的计算机语言。 1.1 SQL语言主要有3个主要的组成部分。 DML(Data Manipulation Language)数据操纵语言。这个模块可以让我们检索、修改、增加、删除数据库中的数据。 DDL(Data Definition Language)数据定义语言。是的我们能够创建和修改数据库本身。如：DDL提供ALTER语句，他让我们可以修改数据库中表的设计。 DCL(Data Control Language)数据控制语言，用于维护数据库的安全。 在SQL术语中，记录(record)和字段(field)实际上就称为行(row)和列(column)。 1.2 主键和外键主键之所以有必要： 首先使你唯一标识表中单独的一行。主键确保了唯一性。 可以很容易的将一个表和另一个表关联。 主键一般就会自动默认创建索引，提高了查询速度。 外键就是说A表中的某个字段，同时是B中的主键，那么这个字段就是A表中的外键。希望A表中的这个外键的值必须是B中已经存在的值。 1.3 数据类型一般来讲，有3中重要的数据类型： 数字(Numeric) 字符(Character) 以及日期/时间(Date/Time) bit是数字型，它只允许两个值，0和1。 字符类型区别^1： 类型 长度 说明 char 固定长度 nchar 固定长度 处理unicode数据类型(所有的字符使用两个字节表示) varchar 可变长度 效率没char高 灵活 nvarchar 可变长度 处理unicode数据类型(所有的字符使用两个字节表示) 1字节=8位 bit就是位，也叫比特位，是计算机表示数据最小的单位。 byte就是字节，1byte=8bit，1byte就是1B； 一个字符=2字节； 1.3 空值空值不等于空格或空白。使用NULL表示空值。 二、简单增删改查2.1 查（列名有空格的情况）12SELECT [ last name]FROM Customers 用方括号将有空格的列名括起来。PS: MySql中用重音符`（~）按键。Oracle用双引号。 查询顺序,SQL执行顺序^2：123456Select -1&gt;选择列,-2&gt;distinct,-3&gt;top 1&gt;…From 表 2&gt;…Where 条件 3&gt;…Group by 列 4&gt;…Having 筛选条件 6&gt;…Order by 列 2.2 增123456INSERT INTO tablename(columnlist)VALUES(RowValues1)(RowValues2)(repeat any number of times) 2.3 改123UPDATE tableSET column1=expression1,column2=expression2(repeat any number of times)WHERE condition 2.4 删123DELETEFROM tableWHERE condition 删除前可以验证一下：1234SELECT COUNT（*）FROM tableWHERE condition 如果想要删除所有的行，可以：1DELETE FROM table 或者1TRUNCATE TABLE table TRUNCATE TABLE优势在于速度更快，但是不提供记录事务的结果。另外一个不同点是，TRUNCATE TABLE重新设置了用于自增型的列的当前值，DELETE不会。 三、别名关键字：AS 3.1 计算字段使用计算字段可以做如下的事情： 选择特定的单词或者数值 对单个或者多个列进行计算 把列和直接量组合在一起。 3.2 直接量这个直接量和表中的数据没有任何关系，就是为了说明所用，下面这种类型的表达式就叫做直接量(literal value)。 12SELECT '直接量' AS `类型`,firstname,lastname FROM `customers` ; 如图，结果中直接量就在一列中了。 3.3 算数运算例子1：12SELECT num*price AS totalFROM orders 例子2：12SELECT firstname+' '+lastname AS 'fullname'FROM users 在MySql中连接要是用CONCAT函数：123SELECT OrderID,FirstName,LastName,CONCAT(FirstName,' ',LastName) AS 'fullname'FROM orders 3.4 别名1）列的别名12SELECT firstname AS fnFROM customers 2） 表的别名12SELECT firstname FROM customers AS cu 说明： 列的别名是为了显示用的，别名会作为查询结果的表头，不能在WHERE中使用列的别名，会出错！！！ 表的别名确实是为了方便操作用的，可以在WHERE中使用列的别名进行！ 四、使用函数函数要有一组圆括号跟在关键字后边，圆括号告诉我们，这是一个函数！ 4.1 字符函数LEFT&amp;RIGHT LEFT(CharacterValue,NumberOfCharacters)含义：选择CharacterValue字段的左边NumberOfCharacters几个字符。ps:RIGHT是右边几个字符。 LTRIM&amp;RTRIM LTRIM(CharacterValue) 可以删除左边开始的空格。RTRIM作用类似。 SUBSTRINGSUBSTRING(CharacterValue,StartPositon,NumberOfCharacters)含义：选择从开始位置（包括），N个长度的字符。12SELECT SUBSTRING('thewhitegoat',4,5) AS 'The Answer' 返回：white 4.2 日期/时间函数GETDATE1SELECT GETDATE() 返回当前日期和时间。PS：在MySql中，等价函数是NOW，在Oracle中是CURRENT_DATE。 DATEPART能够分析具体的日期，并且返回诸如该日期是该月中的第几天，或者该年份中的第几周等信息。1DATEPART(datepart,DateValue) datepart可以是许多不同的值，如下都是有效值： year quarter month dayofyear day week weekday hour minute second DATEDIFF可以让我们得到任意两个日期之间相差的天数（或周数、月数等）。1DATEDIFF(datepart1,startdate1,startdate2) DATEDIFF Function Expression Resulting Value DATEDIFF(day,’7/8/2009’,’8/14/2009’) 37 DATEDIFF(week,’7/8/2009’,’8/14/2009’) 5 DATEDIFF(month,’7/8/2009’,’8/14/2009’) 1 DATEDIFF(year,’7/8/2009’,’8/14/2009’) 0 PS:MySql中，DATEDIFF函数只允许我们计算两个日期之间的天数，如果想要得到一个正数，结束的日期通常要作为第一个参数:1DATEDIFF(enddate,startdate) Oracle中没有等价函数 4.3 数值函数ROUND允许我们四舍五入。1ROUND(numericvalue,decimalpalaces) RAND用来产生随机数1RAND([seed]) 没有参数时，它会返回0-1之间的一个随机数。1SELECT RAND() AS 'Random Value' 可选参数seed有的情况下，每次将返回相同的值。这让我想起了Python中的Random包。看来很多时候，一些东西是共通的啊。 PIPI()函数如果想要对它保留两位小数，可以通过复合函数进行：1SELECT ROUND(PI(),2) 将会返回：3.14 4.4 转换函数CAST函数允许我们把数据从一种类型转换成另一种类型。1CAST(expression AS DateType) 例子：123SELECT '2009-04-11' AS 'Original Date',CAST('2009--04-11' AS DATETIME) AS 'Converted Date' ISNULL函数，很有用可以把NULL值转换成一个有意义的值。123SELECT Description,ISNULL(Color,'Unknown') AS 'Color'FROM Products 五、排序函数5.1 添加排序123SELECT columnlistFROM tablelistORDER BY columnlist 默认是升序，ASC，因此，上面等价于：123SELECT columnlistFROM tablelistORDER BY columnlist ASC 5.2 降序使用DESC关键字：123SELECT columnlistFROM tablelistORDER BY columnlist DESC 5.3 根据多列12345SELECT FirstName,LastNameFROM CustomersORDER BY LastName, FirstName 注意：列的顺序很重要，首先按照LastName排序，然后按照FirstName排序。 5.4 根据计算字段123SELECT LastName+','+FirstName AS 'Name'FROM CustomersORDER BY Name 因此，从这儿可以知道，列别名不可以用在WHERE中，但可以用在ORDER BY中。例子123SELECT FirstName,LastNameFROM CustomersORDER BY LastName+FirstName AS 'Name' 5.5 排序补充内容当数据升序时，出现顺序是如下： NULL-&gt;数字-&gt;字符注意：此时，该列中的数字其实是按照字符来算的，因此，升序时，23也是排在5之前的。 六、基于列的逻辑-CASE6.1 IF-THEN-ELSE逻辑包含列和CASE表达式的SELECT语句，大概如下：12345SELECT column1,column2,CaseExpressionFROM table 6.2 CASE-简单格式1234567SELECT CASE ColumnOrExpressionWHEN value1 THEN result1WHEN value2 THEN result2(repeat WHEN-THEN any number of times)[ELSE DefaultResult]END CASE表达式对于把不好理解的值转换成有意义的描述是很有用的。12345678SELECT CASE CategoryCodeWHEN 'F' THEN 'Fruit'WHEN 'V' THEN 'Vegetable'ELSE 'other'END AS 'Category',ProductDescription As 'Description'FROM Products 6.3 CASE-查询格式1234567SELECT CASE WHEN condition1 THEN result1WHEN condition2 THEN result2(repeat WHEN-THEN any number of times)[ELSE DefaultResult]END 这种格式允许在关键字WHEN后边放置较为复杂的条件表达式。 相关问题： StackOverFlow-SQL Server: CASE WHEN OR THEN ELSE END =&gt; the OR is not supported 七、基于行的逻辑7.1 应用查询条件终于派到WHERE出场了，注意写法顺序，再写一遍：123456Select -1&gt;选择列,-2&gt;distinct,-3&gt;top 1&gt;…From 表 2&gt;…Where 条件 3&gt;…Group by 列 4&gt;…Having 筛选条件 6&gt;…Order by 列 7.2 限制行-TOP1234SELECT TOP Number ColumnlistFROM table 7.3 TOP和ORDER BY结合关键字TOP的另一个用途是，把它和ORDER BY子句结合起来，基于特定分类，得到带有最大值的一定数量的行。 假设你想看到Shakespeare所著的销量最多的书。1234567SELECT TOP1Title AS 'Book Title',CurrentMonthSales AS 'Quantuty Sold'FROM BooksWHERE Author='Shakespeare'ORDER BY CurrentMonthSales DESC ps: 学会利用google搜索，例如，我想要知道oracle中类似top作用的关键字是什么，可以： 八、布尔逻辑关键字：AND/OR/NOT/BETWEEN/IN/IS/NULL 8.1 OROR子句意味着，如果确定任意条件为真，那么就该选中该行。1234SELECT userid,name,phoneFROM usersWHERE age&lt;18OR age&gt;60 8.2 使用圆括号1234567SELECT CustomerName,Sate,QuantityPurchasedFROM OrdersWHERE State ='IL'OR State='CA'AND QuantityPurchased&gt;8 本来想要的结果是对来自IL或者CA的客户，同时，只看数量大于8的订单。但是上面执行的结果不是这样的，因为，SQL总是会先处理AND操作符！！！然后才会处理OR操作符。所以，上述语句中，先看到AND并执行如下的条件12State= 'CA'AND QuantityPurchased&gt;8 因此，要用括号来规定顺序：1234567SELECT CustomerName,Sate,QuantityPurchasedFROM OrdersWHERE (State ='IL'OR State='CA')AND QuantityPurchased&gt;8 8.3 NOT操作符NOT操作符表示对后边的内容否定或者取反。123SELECT CustomerName,StateFROM OrdersWHERE NOT (State='IL' OR Sate='NY') 这个其实可以用AND改写的！！！NOT操作符在逻辑上不是必须的。 8.4 BETWEEN操作符12345SELECT CustomerName,Sate,QuantityPurchasedFROM OrdersWHERE QuantityPurchased BETWEEN 8 AND 10 8.5 IN操作符假设你想看到IL或者NY的行：1234SELECT *FROM OrdersWHERE State='IL'OR State='CA' 可以改写成：123SELECT *FROM OrdersWHERE State IN ('IL','CA') 8.9 布尔逻辑-IS NULL为了将某字段NULL值的行或0的行包括进来：1234SELECT *FROM ProductsWHERE weight=0OR weight IS NULL 或者123SELECT *FROM ProductsWHERE ISNULL(weight,0)=0 九、模糊匹配9.1 LIKE和%搭配%通配符可以表示任意的字符，它可以表示0个，1个，任意多个字符。 9.2 通配符除了%以外，还有下划线（_）、方括号起来的characterlist，以及用方括号括起来的脱字符号（^）加上characterlist。 下划线表示一个字符 [characterlist]表示括号中字符的任意一个 [^characterlist]表示不能是括号中字符的任意一个例子：12345SELECT FirstName,LastNameFROM ActorsWHERE FirstName LIKE '[CM]ARY' 检索以C或者M开头并以ARY结尾的所有行。 9.3 按照读音匹配SOUNDEX和DIFFERENCE 十、汇总数据10.1消除重复使用DISTINCT12SELECT DISTINCE name,ageFROM users 如果age不同，即使name相同，那么这一行就不会被删除重复。 10.2 聚合函数COUNT\SUM\AVG\MIN\MAX，他们提供了对分组数据进行计数、求和、取平均值、取最小值和最大值等方法。12345SELECT AVG(Grade) AS 'Average Quiz Score'MIN(Grade) AS 'Minimum Quiz Score'FROM GradesWHERE GradeType='Quiz' COUNT函数可以有3中不同方式使用它。1.COUNT函数可以用来返回所有选中行的数目，而不管任何特定列的值。例如：下面语句返回GradeType为’HomeWork’的所有行的数目：1234SELECT COUNT(*) AS 'Count of Homework Rows'FROM GradesWHERE GradeType='HomeWork' 这种方式，会计数所有行的个数，即使其中有*NULL。 2.第二种方式指定具体的列1234SELECT COUNT(Grades) AS 'Count of Homework Rows'FROM GradesWHERE GradeType='HomeWork' 第一种方式返回3，这一种方式返回2，为什么？？？因为，这种方式要满足Grades这一列有值，NULL值的行不会计数。 3.使用关键字DISTINCT。123SELECT COUNT(DISTINCT FeeType) AS 'Number of Fee Types'FROM Fees 这条语句计数了FeeType列唯一值的个数。 10.3 分组数据-GROUP BY123456SELECTGradeType AS 'Grade Type',AVG(Grade)AS 'Average Grade'FROM GradesGROUP BY GradeTypeORDER BY GradeType 感觉像EXCEL中的分类汇总功能。如果想把Grade为NULL值的当做0，那么可以用：123456SELECTGradeType AS 'Grade Type',AVG(ISNULL(Grade,0))AS 'Average Grade'FROM GradesGROUP BY GradeTypeORDER BY GradeType GROUP BY子句中的列的顺序是没有意义的； ORDER BY子句中的列的顺序是有意义的。 10.4 基于聚合查询条件-HAVING当针对带GROUP BY的一条SELECT语句应用任何查询条件时，人们必须要问查询条件是应用于单独的行还是整个组。 实际上，WHERE子句是单独的执行查询条件。SQL提供了一个名为HAVING的关键字，它允许对组级别使用查询条件。例子：查看选修了类型为选修“A”，平均成绩在70分以上的学生姓名，平均成绩。12345678SELECT Name,AVG(ISNULL(Grades,0)) AS 'Average Grades'FROM GradesWHERE GradeType='A'GROUP BY NameHAVING AVG(ISNULL(Grades,0))&gt;70ORDER BY Name 修要修类型为A，那么，这是这对行的查询，因此这里要用WHERE。但是，还要筛选平均成绩，那么，这是一个平均值，建立在聚合函数上的，并不是单独的行，这就需要用到关键字HAVING。需要先将Student分组，然后把查询结果应用到基于全组的一个聚合统计上。 WHERE只保证我们选择了GradeType是A的行，HAVING保证平均成绩至少70分以上。 注意：如果想要在结果中添加GradeType的值，如果直接在SELECT后边添加这个列，将会出错。这是因为，所有列都必须要么出现在GROUP BY中，要么包含在一个聚合函数中。123456789SELECT Name,GradeType,AVG(ISNULL(Grades,0)) AS 'Average Grades'FROM GradesWHERE GradeType='A'GROUP BY Name,GradeTypeHAVING AVG(ISNULL(Grades,0))&gt;70ORDER BY Name 十一、组合表11.1 内连接来组合表-Inner Join通过书中的描述，我感觉内连接更像是用来将主键表、外键表连接起来的工具。例如：A表： userid name age 1 michael 26 2 hhh 25 3 xiang 20 B表： orderid userid num price 1 1 2 3 2 2 6 6 3 1 5 5 如上表格，那么要连接这两个表格，查询订单1的客户姓名，年龄，订单号：方式一：1234SELECT name,age,orderidFROM A,BWHERE A.userid=B.useridAND orderid=1 方式二，使用现在的内连接实现：12345SELECT name,age,orderidFROM AINNER JOIN BON A.userid=B.useridAND orderid=1 ON关键字指定两个表如何准确的连接。 内连接中表的顺序：FROM 子句指定了A表，INNER JOIN 子句指定B表，我们调换A,B顺序，所得到的结果相同的!只是显示列的顺序可能会不同而已。 不建议使用方式一的格式。关键字INNER JOIN ON的优点在于显示地表示了连接的逻辑，那是它们唯一的用途。WEHERE的含义不够明显。因为它是条件的意思啊，不是连接的！ 11.2 外连接外连接分为左连接（LEFT OUTER JOIN)、右连接(RIGHT OUTER JOIN)、全连接（FULL OUTER JOIN)。 OUTER是可以省略的。 左连接（LEFT JOIN)12345SELECT name,age,orderidFROM ALEFT JOIN BON A.userid=B.useridAND orderid=1 外连接的强大之处在于，主表中的数据必然都会保留，从表中列没有值的情况，用NULL补充。 LEFT JOIN 左边的表为主表，右边的表为从表。 11.3 自连接自连接必然用到表的别名。1234SELECT A.name,B.name as ManagerNameFROM worker as ALEFT JOIN worker as BON A.managerid=B.id 11.4 创建视图123CREATE VIEW ViewName ASSelectStatement[WITH CHECK OPTION] 视图中不能包含ORDER BY子句。 [WITH CHECK OPTION]表示对视图进行UPDATE,INSERT,DELETE操作时任然保证了视图定义时的条件表达式。 删除视图：1DROP VIEW ViewName 修改视图：12ALTER VIEW ViewName ASSelectStatement 视图的优点 简化用户的操作 使用户以多角度看待同一数据 对重构数据库提供了一定程度的逻辑独立性 对机密数据提供安全保护 十二、补充12.1 子查询可以用3种主要的方式来指定子查询，总结如下： 当子查询是tablelist的一部分时，它指定了一个数据源。 当子查询是condition的一部分时，它成为查询条件的一部分。 当子查询是columnlist的一部分时，它创建了一个单个的计算的列。 12.2 索引索引是一种物理结构，可以为数据库表中任意的列添加索引。 索引的目的是，当SQL语句中包含该列的是偶，可以加速数据的检索。 索引的缺点是，在数据库中，索引需要更多的存储硬盘。另一个负面因素是，索引通常会降低相关的列数据更新速度。这是因为，任何时候插入或者修改一行记录时，索引都必须重新计算该列中的值的正确的排列顺序。 可以对任意的列进行索引，但是只能指定一个列作为主键。指定一个列作为主键意味着两件事情：首先这个列成为了索引，其次保证这列包含唯一的值。12CREATE INDEX Index2ON MyTable (ColumnFour) 删除一个索引：12DROP INDX Index2ON MyTable 参考： SQL总结（一）基本查询 SQL Server 常用高级语法笔记 史上最全的SQL Server复习笔记一 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016读书-书单整理]]></title>
      <url>%2F2016%2F02%2F26%2Fbooks-list-2016%2F</url>
      <content type="text"><![CDATA[书籍是人类进步的阶梯。 前几天无意看到了一个视频，这位老先生说了一个故事，学习读书的时候，不要因为书中有不好的地方，就不去读这本书，因为不可能每本书都完美无暇！我们要先看到这本书里值得学习的、好的地方，然后再去看到它不好的地方！ 技术书籍 《机器学习》这是知乎关于这本书的讨论，不管是否是软文，周志华老师的口碑还是不错的，亚马逊订一本，充值信仰！南大周志华的《机器学习》这本书怎么样？ Python算法教程当初学习数据结构就不认真，现在还是要打打基础啊，欠下的债，迟早要还的！ 《利用Python进行数据分析》学习数据分析，这本书还是应该要读一读的！ 《写给程序员的数据挖掘实践指南》入门图书，主要介绍推荐系统相关的内容 统计分析 《商务与经济统计》概率统计的概念和实际背景知识联系起来，很棒，推荐！ 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python编码问题总结]]></title>
      <url>%2F2015%2F12%2F29%2Fpython-encoding-error%2F</url>
      <content type="text"><![CDATA[Python编码问题一直是头疼的东西，这篇文章就用来记录整理Python编码相关的问题以及IDE编码问题的解决办法好了。会不断补充的。 Pyscripter出现编码错误Pyscripter错误今天使用Pyscripter编辑python时，出现了这样的错误提示：1pyscripter UnicodeEncodeError: 'ascii' codec can't encode characters in position 1-2: ordinal not in range(128) 为了解决这个错误，百度了好半天，各种说法，最后总算给我找到了一个靠谱的解决方案： Pyscripter错误解决办法运行-&gt;python引擎-&gt;勾选内部 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搜狗输入法使用技巧整理]]></title>
      <url>%2F2015%2F12%2F28%2Ftools-sougoupinyin%2F</url>
      <content type="text"><![CDATA[现在的输入法有很多，但是，哪个最好呢？不必纠结，自己用着顺手的才是最好！ 自己选择搜狗输入法的原因很简单，因为，它支持的平台多，同时，各个平台更新也很积极。从兼容性的角度考虑，还是最后选择了搜狗。至于搜狗启动的广告之类，其实不怕麻烦，是可以在设置里选择不弹出的。 作为每天使用最多的输入法，我觉得，花点时间了解它一下还是值得的，你说呢？毕竟是与我们共同作战的小伙伴啊！ 输入罗马数字+计算器属性设置-&gt;高级 需要输入罗马数字时，采用：v+”数字”，然后可以看见候选数字中有罗马数字了。 v+计算式子 就能直接获得结果 输入法截图右击输入法进入搜狗工具箱。按键-&gt;扩展功能快捷键 设置截图快捷键之后，就可以通过快捷键快速截图了！这样需要截图的时候就不需要开qq！足以应付日常的截图功能了，至于专业的，还是找专业截图的工具好了…… 自定义短语属性设置-&gt;高级-&gt;自定义短语如图，可以通过设置自定义短语，从而达到快速输入一些短语的功能。例如：设置缩写qq对应短语’你的qq邮箱’,那么下次在你需要输入QQ邮箱的时候，只需要输入qq就能显示邮箱候选了。 鼠标手势没想到，搜狗输入法鼠标手势也有，再方便不过了。可以通过扩展箱安装。如果担心鼠标手势和某些应用程序内的手势冲突，可以通过设置来定义在某些程序里边不启用鼠标手势。PS：现在已经喜欢上搜狗鼠标手势的全局缩小，全局最大化的功能了。浏览器一下子可以快速最小化和最大化呢。防止boss突袭。 手写输入通过扩展工具箱里的首席输入扩展，可以在遇到陌生字时，手写输入。 Tab拆字辅助码笔画笔画筛选用于输入单字时，用笔顺来快速定位该字。使用方法是输入一个字或多个字后，按下tab键（tab键如果是翻页的话也不受影响），然后用h横、s 竖、p撇、n捺、z折依次输入第一个字的笔顺，一直找到该字为止。五个笔顺的规则同上面的笔画输入的规则。要退出笔画筛选模式，只需删掉已经输入的笔画辅助码即可。 例如，快速定位【珍】字，输入了zhen后，按下【tab】，然后输入珍的前两笔【hh】，就可定位该字。 或者输入一个不怎么用的词：威赫（wei he），这个词不在第一页，这种情况下不要翻页。输入weihe，然后按tab键，会进入一个笔画模式，你可以用横撇竖点（hpsd）定位到字。这里，“威”字笔顺是横、撇、横、撇点、撇、横、斜钩、撇、点，所以你输入weihe之后，按一下tab，然后输入hp，看看是不是把第一个字是威的提到前 面了？如果还不够精确，可以继续输入下面的笔画，一般输入3笔左右就够了，然后按0只显示单字，选中威之后再选下一个。 Tab拆字辅助码拼音拆字辅助码让你快速的定位到一个单字，使用方法如下：想输入一个汉字【娴】，但是非常靠后，找不到，那么输入【xian】，然后按下【tab】键，在输入【娴】的两部分【女】【闲】的首字母nx，就可以看到只剩下【娴】字了。输入的顺序为xian+tab+nx。 难字按u键进行偏旁和笔画输入U模式是专门为输入不会读的字所设计的。在输入u键后，然后依次输入一个字的笔顺，笔顺为：h横、s竖、p撇、n捺、z折，就可以得到该字，同时小键盘上的1、2、3、4、5也代表h、s、p、n、z。这里的笔顺规则与普通手机上的五笔画输入是完全一样的。其中点也可以用d来输入。由于双拼占用了u键，智能ABC的笔画规则不是五笔画，所以双拼和智能ABC下都没有u键模式。 对于只认识偏旁部首，不清楚字音的字，像“黏”、“亓”等，我们可以这样输入：u+偏旁部首的读音，或者u+字的顺序笔画。对于即清楚字形，又清楚字音的，只是候选位置比较靠后的字，比如“幂”、“祎”等，我们可以这样输入： 读音+tab键+偏旁的读音首字母，例如“幂”字的偏旁是“秃宝盖”，对应的字母就是“t”，“祎”字的偏旁部首对应的读音分别是“s”（示补旁）、“w”（韦）。对于只知道读音，不清楚怎么写的字，我们可以这样输入： 比如“耄”，我们知道它是“耄耋”中的一个字，可以输入maodie，然后按“[”键，上屏当前候选第一个字； 比如“餮”，我们知道它是“饕餮”中的一个字，可以输入taotie，然后按“]”键，上屏当前候选第二个字； 生活小技巧（农历，诗句等） 键入rq选择1得到××××年××月××日格式时间，选择2得到××××-××-××格式时间，选择3得到例如二〇〇八年三月三十一日的时间 键入llysc选择2得到：离离原上草，一岁一枯荣。野火烧不尽，春风吹又生。远芳侵古道，晴翠接荒城。又送王孙去，萋萋满别情。 比较常用的特殊符号，如↑之类 键入pai选择3得到π 键入aerfa选择2得到希腊字母α，依此类推 键入wjx选择3、4分别得到☆和★ 键入sjt、xjt、zjt、yjt分别得到↑、↓、←和→ 键入sjx选择3、4分别得到△和▲ 参考： 搜狗输入法使用实用技巧分享 拼音输入法有哪些鲜为人知的技巧？ 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[遗传算法GA(Genetic Algorithm)入门知识梳理]]></title>
      <url>%2F2015%2F12%2F24%2Falgorithm-GA-basic%2F</url>
      <content type="text"><![CDATA[一、遗传算法进化论背景知识作为遗传算法生物背景的介绍，下面内容了解即可： 种群(Population)：生物的进化以群体的形式进行，这样的一个群体称为种群。 个体：组成种群的单个生物。 基因 ( Gene ) ：一个遗传因子。 染色体 ( Chromosome ) ：包含一组的基因。 生存竞争，适者生存：对环境适应度高的、牛B的个体参与繁殖的机会比较多，后代就会越来越多。适应度低的个体参与繁殖的机会比较少，后代就会越来越少。 遗传与变异：新个体会遗传父母双方各一部分的基因，同时有一定的概率发生基因变异。 简单说来就是：繁殖过程，会发生基因交叉( Crossover ) ，基因突变 ( Mutation ) ，适应度( Fitness )低的个体会被逐步淘汰，而适应度高的个体会越来越多。那么经过N代的自然选择后，保存下来的个体都是适应度很高的，其中很可能包含史上产生的适应度最高的那个个体。 二、遗传算法思想GA的组成: 编码（产生初始种群） 适应度函数 遗传算子（选择、交叉、变异） 运行参数 借鉴生物进化论，遗传算法将要解决的问题模拟成一个生物进化的过程，通过复制、交叉、突变等操作产生下一代的解，并逐步淘汰掉适应度函数值低的解，增加适应度函数值高的解。这样进化N代后就很有可能会进化出适应度函数值很高的个体。 举个例子，使用遗传算法解决“0-1背包问题”的思路：0-1背包的解可以编码为一串0-1字符串（0：不取，1：取） ；首先，随机产生M个0-1字符串，然后评价这些0-1字符串作为0-1背包问题的解的优劣；然后，随机选择一些字符串通过交叉、突变等操作产生下一代的M个字符串，而且较优的解被选中的概率要比较高。这样经过G代的进化后就可能会产生出0-1背包问题的一个“近似最优解”。 2.1 编码需要将问题的解编码成字符串的形式才能使用遗传算法。最简单的一种编码方式是二进制编码，即将问题的解编码成二进制位数组的形式。例如，问题的解是整数，那么可以将其编码成二进制位数组的形式。将0-1字符串作为0-1背包问题的解就属于二进制编码。 基因在一定能够意义上包含了它所代表的问题的解。基因的编码方式有很多，这也取决于要解决的问题本身。常见的编码方式有： 二进制编码，基因用0或1表示（常用于解决01背包问题） 如：基因A：00100011010 (代表一个个体的染色体) 互换编码（用于解决排序问题，如旅行商问题和调度问题） 如旅行商问题中，一串基因编码用来表示遍历的城市顺序，如：234517986，表示九个城市中，先经过城市2，再经过城市3，依此类推。 树形编码（用于遗传规划中的演化编程或者表示） 如,问题：给定了很多组输入和输出。请你为这些输入输出选择一个函数，使得这个函数把每个输入尽可能近地映射为输出。 编码方法：基因就是树形结构中的一些函数。 值编码 （二进制编码不好用时，解决复杂的数值问题） 在值编码中，每个基因就是一串取值。这些取值可以是与问题有关任何值：整数，实数，字符或者其他一些更复杂的东西。 2.2 适应度函数适应度函数 ( Fitness Function )：用于评价某个染色体的适应度，用f(x)表示。有时需要区分染色体的适应度函数与问题的目标函数。例如：0-1背包问题的目标函数是所取得物品价值，但将物品价值作为染色体的适应度函数可能并不一定适合。适应度函数与目标函数是正相关的，可对目标函数作一些变形来得到适应度函数。 遗传算子：遗传算法有3个最基本的操作：选择，交叉，变异。 2.3 选择选择一些染色体来产生下一代。一种常用的选择策略是 “比例选择”，也就是个体被选中的概率与其适应度函数值成正比。假设群体的个体总数是M，那么那么一个体Xi被选中的概率为f(Xi)/( f(X1) + f(X2) + …….. + f(Xn) ) 。比例选择实现算法就是所谓的“轮盘赌算法”( Roulette Wheel Selection )。 123456789101112131415161718192021222324252627282930313233轮盘赌算法/** 按设定的概率，随机选中一个个体* P[i]表示第i个个体被选中的概率*/int RWS()&#123;m =0;r =Random(0,1); //r为0至1的随机数for(i=1;i&lt;=N; i++)&#123;/* 产生的随机数在m~m+P[i]间则认为选中了i* 因此i被选中的概率是P[i]*/m = m + P[i];if(r&lt;=m) return i; 2.4 交叉所谓交叉运算，是指对两个相互配对的染色体依据交叉概率按某种方式相互交换其部分基因，从而形成两个新的个体。交叉运算在GA中起关键作用，是产生新个体的主要方法。 2.4.1 2条染色体交换部分基因，来构造下一代的2条新的染色体。例如：交叉前： 00000|011100000000|10000 11100|000001111110|00101 交叉后： 00000|000001111110|10000 11100|011100000000|00101 染色体交叉是以一定的概率发生的，这个概率记为Pc 。 2.4.2 双交叉点法 （用于二进制编码）选择两个交叉点,子代基因在两个交叉点间部分来自一个父代基因,其余部分来自于另外一个父代基因. 如： 交叉前： 01 |0010| 11 11 |0111| 01 交叉后： 11 |0010| 01 01 |0111| 11 2.4.3. 基于“ 与/或 ”交叉法 （用于二进制编码）对父代按位”与”逻辑运算产生一子代A;按位”或”逻辑运算产生另一子代B。该交叉策略在解背包问题中效果较好 . 如： 交叉前： 01001011 11011101 交叉后： 01001001 11011111 还有其他交叉方法，参考遗传算法学习心得 2.5 变异变异是指依据变异概率将个体编码串中的某些基因值用其它基因值来替换，从而形成一个新的个体。GA中的变异运算是产生新个体的辅助方法，它决定了GA的局部搜索能力，同时保持种群的多样性。交叉运算和变异运算的相互配合，共同完成对搜索空间的全局搜索和局部搜索。 注：变异概率Pm不能太小，这样降低全局搜索能力；也不能太大，Pm &gt; 0.5，这时GA退化为随机搜索。 在繁殖过程，新产生的染色体中的基因会以一定的概率出错，称为变异。变异发生的概率记为Pm 。 2.5.1. 基本位变异算子 （用于二进制编码）基本位变异算子是指对个体编码串随机指定的某一位或某几位基因作变异运算。对于基本遗传算法中用二进制编码符号串所表示的个体，若需要进行变异操作的某一基因座上的原有基因值为0，则变异操作将其变为1；反之，若原有基因值为1，则变异操作将其变为0。 变异前： 000001110000000010000 变异后： 000001110000100010000 2.5.2. 逆转变异算子（用于互换编码）在个体中随机挑选两个逆转点，再将两个逆转点间的基因交换。 如： 变异前： 1346798205 变异后： 1246798305 2.6 运行参数GA运行时选择的参数应该视解决的具体问题而定，到目前为止，还没有一个适用于GA所有应用领域的关于算法参数的理论。下面是一般情况下使用GA时推荐的参数： 2.6.1 交叉率交叉率一般来说应该比较大，推荐使用80％-95％。 2.6.2 变异率变异率一般来说应该比较小，一般使用0.5％-1％最好。 2.6.3 种群的规模种群规模指的是群体中个体的个数。实验发现，比较大的种群的规模并不能优化遗传算法的结果。种群的大小推荐使用20-30，一些研究表明，种群规模 的大小取决于编码的方法，具体的说就是编码串（Encoded String）的大小。也就是说，如果说采用32位为基因编码的时候种群的规模大小最好为32的话，那么当采用16位为基因编码时种群的规模相应应变为原 来的两倍。 2.6.4 遗传运算的终止进化代数个人的想法是，设定一个计数器，如果连续N代出现的最优个体的适应度都一样时，（严格的说应该是，连续N代子代种群的最优个体适应度都&lt;=父代最优个性的适应度）可以终止运算。 三、SGA（基本遗传算法）的伪代码SGA（基本遗传算法）中采用轮盘赌选择方法 3.1算法流程图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960基本遗传算法伪代码/** Pc：交叉发生的概率* Pm：变异发生的概率* M：种群规模* G：终止进化的代数* Tf：进化产生的任何一个个体的适应度函数超过Tf，则可以终止进化过程*/初始化Pm，Pc，M，G，Tf等参数。随机产生第一代种群Popdo&#123; 计算种群Pop中每一个体的适应度F(i)。 初始化空种群newPop do &#123; 根据适应度以比例选择算法从种群Pop中选出2个个体 if ( random ( 0 , 1 ) &lt; Pc ) &#123; 对2个个体按交叉概率Pc执行交叉操作 &#125; if ( random ( 0 , 1 ) &lt; Pm ) &#123; 对2个个体按变异概率Pm执行变异操作 &#125;将2个新个体加入种群newPop中&#125; until ( M个子代被创建 )用newPop取代Pop&#125;until ( 任何染色体得分超过Tf， 或繁殖代数超过G ) 四、基本遗传算法的优化下面的方法可优化遗传算法的性能。 4.1 灾变遗传算法的局部搜索能力较强，但是很容易陷入局部极值。引用网上的一段原话: “那么如何解决遗传算法容易陷入局部极值的问题呢？让我们来看看大自然提供的方案。 六千五百万年以前，恐龙和灵长类动物并存，恐龙在地球上占绝对统 治地位，如果恐龙没有灭绝灵长类动物是绝没有可能统治地球的。正是恐龙的灭绝才使灵长类动物有了充分进化的余地，事实上地球至少经历了5次物种大灭绝，每 次物种灭绝都给更加高级的生物提供了充分进化的余地。所以要跳出局部极值就必须杀死当前所有的优秀个体，从而让远离当前极值的点有充分的进化余地。这就是灾变的思想。” 灾变就是杀掉最优秀的个体，这样才可能产生更优秀的物种。那何时进行灾变，灾变次数又如何设定？ 何时进行灾变，可以采用灾变倒计数的方式。如果n代还没有出现比之前更优秀的个体时，可以发生灾变。灾变次数可以这样来确定，如果若干次灾变后产生的个体的适应度与没灾变前的一样，可停止灾变。 4.2 精英主义(Elitist Strategy)选择：当利用交叉和变异产生新的一代时，我们有很大的可能把在某个中间步骤中得到的最优解丢失。 精英主义的思想是,在每一次产生新的一代时，首先把当前最优解原封不动的复制到新的一代中。然后按照前面所说的那样做就行。精英主义方法可以大幅提高运算速度，因为它可以防止丢失掉找到的最好的解。 精英主义是基本遗传算法的一种优化。为了防止进化过程中产生的最优解被交叉和变异所破坏，可以将每一代中的最优解原封不动的复制到下一代中。 4.3 矛盾由上面看来,灾变与精英主义之间似乎存在着矛盾.前者是将产生的最优个体杀掉,而后者是将最优秀个体基因直接保存到下一代. 应该辩证地看待它们之间的矛盾,两者其实是可以共存的.我们在每一代进行交叉运算时,均直接把最优秀的个体复制到下一代;但当连续N代,都没有更优 秀的个体出现时,便可以猜想可能陷入局部最优解了,这样可以采用灾变的手段.可以说,精英主义是伴随的每一代的,但灾变却不需要经常发生,否则算法可能下 降为随机搜索了. 当然,每个算法中不一定要用精英主义和灾变的手段,应该根据具体的问题而定 4.4 插入操作：可在3个基本操作的基础上增加一个插入操作。插入操作将染色体中的某个随机的片段移位到另一个随机的位置。 五、GA算法特点5.1 遗传算法的优点: 群体搜索，易于并行化处理； 不是盲目穷举，而是启发式搜索； 适应度函数不受连续、可微等条件的约束，适用范围很广。 容易实现。一旦有了一个遗传算法的程序，如果想解决一个新的问题，只需针对新的问题重新进行基因编码就行；如果编码方法也相同，那只需要改变一下适应度函数就可以了。 5.2 遗传算法的缺点: 全局搜索能力不强,很容易陷入局部最优解跳不出来；(可结合SA进行改进,因为SA在理率上是100%得到全局最优的,但搜索代价高) 将遗传算法用于解决各种实际问题后，人们发现遣传算法也会由于各种原因过早向目标函数的局部最优解收敛，从而很难找到全局最优解。其中有些是由于目标函数的特性造成的，例如函数具有欺骗性，不满足构造模块假说等等；另外一些则是由于算法设计不当。为此，不断有人对遗传算法提出各种各样的改进方案。例如：针对原先的定长二进制编码方案；提出了动态编码、实数编码等改进方案；针对按比例的选择机制，提出了竞争选择、按续挑选等改进方案；针对原先的一点交算子，提出了两点交、多点交、均匀交等算子；针对原先遗传算法各控制参数在进化过程中不变的情况，提出了退化遗传算法、自适应遗传算法等。另外，针对不同问题还出现了分布式遗传算法、并行遗传算法等等。 六、遗传算法的实例参考：参考文献都是干货！！！参考文献都是干货！！！参考文献都是干货！！！ 遗传算法入门-博客园-苍梧本文主要参考，推荐！感谢作者~ 经典算法研究系列：七、深入浅出遗传算法July大神写的，通俗易懂，推荐！！！ HELLO，遗传算法！博主语言轻松，用python描述了遗传算法求解一个函数最大值的例子。 遗传算法理论基础与简单应用实例博主总结整理的内容，挺不错的，文中的链接有实例应用。 遗传算法入门到掌握（一） CSDN-GA代码下载袋鼠跳的例子来描述了GA算法，帮助理解GA。 非常好的理解遗传算法的例子求下述二元函数的最大值的例子 遗传算法学习心得 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python数据分析入门之pandas总结基础]]></title>
      <url>%2F2015%2F12%2F23%2Fpython-pandas-basic%2F</url>
      <content type="text"><![CDATA[Pandas–“大熊猫”基础SeriesSeries: pandas的长枪(数据表中的一列或一行,观测向量,一维数组…) 12345678Series1 = pd.Series(np.random.randn(4))print Series1,type(Series1) print Series1.indexprint Series1.values 输出结果： 12345678910111213140 -0.6762561 0.5330142 -0.9352123 -0.940822dtype: float64 &lt;class 'pandas.core.series.Series'&gt;Int64Index([0, 1, 2, 3], dtype='int64')[-0.67625578 0.53301431 -0.93521212 -0.94082195] np.random.randn() 正态分布相关。函数说明 Series⽀持过滤的原理就如同NumPy1234print Series1&gt;0 print Series1[Series1&gt;0] 输出结果如下： 12345678910111213140 0.0304801 0.0727462 -0.1866073 -1.412244dtype: float64 &lt;class 'pandas.core.series.Series'&gt;Int64Index([0, 1, 2, 3], dtype='int64')[ 0.03048042 0.07274621 -0.18660749 -1.41224432] 我发现，逻辑表达式，获得的值就是True或者False。要先取得值，还是要X[y]的形式。 当然也支持广播Broadcasting什么是broadcasting,暂时我也不太清楚，看个栗子： 1234print Series1*2 print Series1+5 输出结果如下： 123456789101112131415161718190 0.060961 1 0.145492 2 -0.373215 3 -2.824489 dtype: float64 0 5.030480 1 5.072746 2 4.813393 3 3.587756 dtype: float64 以及Universal Functionnumpy.frompyfunc(out,nin,nout) 返回的是一个函数，nin是输入的参数个数，nout是函数返回的对象的个数函数说明 在序列上就使用行标，而不是创建1个2列的数据表，能够轻松辨别哪是数据，哪是元数据这句话的意思，我的理解是序列尽量是一列，不用去创建2列，这样子，使用index就能指定数据了 12345678910Series2 = pd.Series(Series1.values,index=['norm_'+unicode(i) for i in xrange(4)])print Series2,type(Series2)print Series2.indexprint type(Series2.index)print Series2.values 输出结果如下，可以看到，它是通过修改了index值的样式，并没有创建2列。 12345678910111213141516norm_0 -0.676256norm_1 0.533014norm_2 -0.935212norm_3 -0.940822dtype: float64 &lt;class 'pandas.core.series.Series'&gt;Index([u'norm_0', u'norm_1', u'norm_2', u'norm_3'], dtype='object')&lt;class 'pandas.core.index.Index'&gt;[-0.67625578 0.53301431 -0.93521212 -0.94082195] 虽然行是有顺序的，但是仍然能够通过行级的index来访问到数据： （当然也不尽然像Ordered Dict，因为⾏索引甚⾄可以重复，不推荐重复的行索引不代表不能用） 12print Series2[['norm_0','norm_3']] 可以看到，读取数据时，确实要采用X[y]的格式。这里X[[y]]是因为，它要读取两个数据，指定的是这两个数据的index值，将index值存放进list中，然后读取。输出结果如下： 123456norm_0 -0.676256norm_3 -0.940822dtype: float64 再比如： 1234print 'norm_0' in Series2print 'norm_6' in Series2 输出结果： 1234TrueFalse 逻辑表达式的输出结果，布尔型值。 从Key不重复的Ordered Dict或者从Dict来定义Series就不需要担心行索引重复：12345678910Series3_Dict = &#123;"Japan":"Tokyo","S.Korea":"Seoul","China":"Beijing"&#125;Series3_pdSeries = pd.Series(Series3_Dict)print Series3_pdSeriesprint Series3_pdSeries.valuesprint Series3_pdSeries.index 输出结果： 123456789101112China BeijingJapan TokyoS.Korea Seouldtype: object['Beijing' 'Tokyo' 'Seoul']Index([u'China', u'Japan', u'S.Korea'], dtype='object') 通过上面的输出结果就知道了，输出结果是无序的，和输入顺序无关。 想让序列按你的排序⽅式保存？就算有缺失值都毫无问题 1234567891011121314Series4_IndexList = ["Japan","China","Singapore","S.Korea"]Series4_pdSeries = pd.Series( Series3_Dict ,index = Series4_IndexList)print Series4_pdSeriesprint Series4_pdSeries.valuesprint Series4_pdSeries.indexprint Series4_pdSeries.isnull()print Series4_pdSeries.notnull() 上面这样的输出就会按照list中定义的顺序输出结果。 整个序列级别的元数据信息：name 当数据序列以及index本身有了名字，就可以更方便的进行后续的数据关联啦！ 这里我感觉就是列名的作用。下面举例： 1234print Series4_pdSeries.nameprint Series4_pdSeries.index.name 很显然，输出的结果都是None，因为我们还没指定name嘛！ 123456Series4_pdSeries.name = "Capital Series"Series4_pdSeries.index.name = "Nation"print Series4_pdSeries 输出结果： 123456789101112NationJapan TokyoChina BeijingSingapore NaNS.Korea SeoulName: Capital Series, dtype: object “字典”？不是的，⾏index可以重复，尽管不推荐。 12345678Series5_IndexList = ['A','B','B','C']Series5 = pd.Series(Series1.values,index = Series5_IndexList)print Series5print Series5[['B','A']] 输出结果： 123456789101112131415161718A 0.030480B 0.072746B -0.186607C -1.412244dtype: float64B 0.072746B -0.186607A 0.030480dtype: float64 我们可以看出，Series[‘B’]输出了两个值，所以index值尽量不要重复呀！ DataFrameDataFrame：pandas的战锤(数据表，⼆维数组) Series的有序集合，就像R的DataFrame一样方便。 仔细想想，绝大部分的数据形式都可以表现为DataFrame。 从NumPy二维数组、从文件或者从数据库定义：数据虽好，勿忘列名123456dataNumPy = np.asarray([('Japan','Tokyo',4000),('S.Korea','Seoul',1300),('China','Beijing',9100)])DF1 = pd.DataFrame(dataNumPy,columns=['nation','capital','GDP'])DF1 这里DataFrame中的columns应该就是列名的意思。现在看print的结果，是不是很舒服啊！Excel的样式嘛 等长的列数据保存在一个字典里（JSON）：很不幸，字典key是无序的123456dataDict = &#123;'nation':['Japan','S.Korea','China'],'capital':['Tokyo','Seoul','Beijing'],'GDP':[4900,1300,9100]&#125;DF2 = pd.DataFrame(dataDict)DF2 输出结果可以发现，无序的！ 1234567 GDP capital nation0 4900 Tokyo Japan1 1300 Seoul S.Korea2 9100 Beijing China PS:由于懒得截图放过来，这里没有了边框线。 从另一个DataFrame定义DataFrame：啊，强迫症犯了！1234DF21 = pd.DataFrame(DF2,columns=['nation','capital','GDP'])DF21 很明显，这里是利用DF2定义DF21，还通过指定cloumns改变了列名的顺序。 1234DF22 = pd.DataFrame(DF2,columns=['nation','capital','GDP'],index = [2,0,1])DF22 很明显，这里定义了columns的顺序，还定义了index的顺序。 12345678nation capital GDP2 China Beijing 91000 Japan Tokyo 49001 S.Korea Seoul 1300 从DataFrame中取出列？两种方法（与JavaScript完全一致！）OMG，囧，我竟然都快忘了js语法了，现在想起了，但是对象的属性既可以obj.x也可以obj[x]。 ‘.’的写法容易与其他预留关键字产生冲突 ‘[ ]’的写法最安全。 从DataFrame中取出行？（至少）两种⽅法： 方法1和方法2： 1234print DF22[0:1] #给出的实际是DataFrameprint DF22.ix[0] #通过对应Index给出⾏,**ix**好爽。 输出结果： 123456789101112 nation capital GDP2 China Beijing 9100nation Japancapital TokyoGDP 4900Name: 0, dtype: object 方法3 像NumPy切片一样的终极招式：iloc ： 1234print DF22.iloc[0,:] #第一个参数是第几行，第二个参数是列。这里呢，就是第0行，全部列print DF22.iloc[:,0] #根据上面的描述，这里是全部行，第0列 输出结果，验证一下： 12345678910111213141516nation Chinacapital BeijingGDP 9100Name: 2, dtype: object2 China0 Japan1 S.KoreaName: nation, dtype: object 动态增加列列，但是无法用”.”的方式，只能用”[]”举个栗子说明一下就明白了： 1234DF22['population'] = [1600,130,55]DF22 输出结果： 12345678nation capital GDP population2 China Beijing 9100 16000 Japan Tokyo 4900 1301 S.Korea Seoul 1300 55 Index：行级索引Index：pandas进⾏数据操纵的鬼牌（行级索引） ⾏级索引是： 元数据 可能由真实数据产生，因此可以视作数据 可以由多重索引也就是多个列组合而成 可以和列名进行交换，也可以进行堆叠和展开，达到Excel透视表效果 Index有四种…哦不，很多种写法，⼀些重要的索引类型包括： pd.Index（普通） Int64Index（数值型索引） MultiIndex（多重索引，在数据操纵中更详细描述） DatetimeIndex（以时间格式作为索引） PeriodIndex （含周期的时间格式作为索引） 直接定义普通索引，长得就和普通的Series⼀样12345678index_names = ['a','b','c']Series_for_Index = pd.Series(index_names)print pd.Index(index_names)print pd.Index(Series_for_Index) 输出结果： 1234Index([u'a', u'b', u'c'], dtype='object')Index([u'a', u'b', u'c'], dtype='object') 可惜Immutable，牢记！ 不可变！举例如下：此处挖坑啊。不明白…… 12345678index_names = ['a','b','c'] index0 = pd.Index(index_names) print index0.get_values() index0[2] = 'd' 输出结果如下： 1234567891011121314151617181920212223242526272829303132['a' 'b' 'c']---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-36-f34da0a8623c&gt; in &lt;module&gt;() 2 index0 = pd.Index(index_names) 3 print index0.get_values()----&gt; 4 index0[2] = 'd'C:\Anaconda\lib\site-packages\pandas\core\index.pyc in __setitem__(self, key, value) 1055 1056 def __setitem__(self, key, value):-&gt; 1057 raise TypeError("Indexes does not support mutable operations") 1058 1059 def __getitem__(self, key):TypeError: Indexes does not support mutable operations 扔进去一个含有多元组的List，就有了MultiIndex可惜，如果这个List Comprehension改成小括号，就不对了。 123456multi1 = pd.Index([('Row_'+str(x+1),'Col_'+str(y+1)) for x in xrange(4) for y in xrange(4)])multi1.name = ['index1','index2']print multi1 输出结果： 1234MultiIndex(levels=[[u'Row_1', u'Row_2', u'Row_3', u'Row_4'], [u'Col_1', u'Col_2', u'Col_3', u'Col_4']], labels=[[0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3], [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]]) 对于Series来说，如果拥有了多重Index，数据，变形！下列代码说明： 二重MultiIndex的Series可以unstack()成DataFrame DataFrame可以stack成拥有⼆重MultiIndex的Series 1234data_for_multi1 = pd.Series(xrange(0,16),index=multi1)data_for_multi1 输出结果： 1234567891011121314151617181920212223242526272829Row_1 Col_1 0 Col_2 1 Col_3 2 Col_4 3Row_2 Col_1 4 Col_2 5 Col_3 6 Col_4 7Row_3 Col_1 8 Col_2 9 Col_3 10 Col_4 11Row_4 Col_1 12 Col_2 13 Col_3 14 Col_4 15dtype: int32 看到输出结果，好像明白了点，有点类似Excel汇总一样。不过，日后还得查点资料 二重MultiIndex的Series可以unstack()成DataFrame12data_for_multi1.unstack() DataFrame可以stack成拥有⼆重MultiIndex的Series12data_for_multi1.unstack().stack() 输出结果： 12345678910111213141516171819202122232425262728293031323334Row_1 Col_1 0 Col_2 1 Col_3 2 Col_4 3Row_2 Col_1 4 Col_2 5 Col_3 6 Col_4 7Row_3 Col_1 8 Col_2 9 Col_3 10 Col_4 11Row_4 Col_1 12 Col_2 13 Col_3 14 Col_4 15dtype: int32 非平衡数据的例子：1234multi2 = pd.Index([('Row_'+str(x+1),'Col_'+str(y+1)) for x in xrange(5) for y in xrange(x)])multi2 输出结果： 1234MultiIndex(levels=[[u'Row_2', u'Row_3', u'Row_4', u'Row_5'], [u'Col_1', u'Col_2', u'Col_3', u'Col_4']], labels=[[0, 1, 1, 2, 2, 2, 3, 3, 3, 3], [0, 0, 1, 0, 1, 2, 0, 1, 2, 3]]) 12data_for_multi2 = pd.Series(np.arange(10),index = multi2) data_for_multi2 输出结果： 12345678910111213141516171819202122Row_2 Col_1 0Row_3 Col_1 1 Col_2 2Row_4 Col_1 3 Col_2 4 Col_3 5Row_5 Col_1 6 Col_2 7 Col_3 8 Col_4 9dtype: int32 DateTime标准库如此好⽤，你值得拥有123456import datetimedates = [datetime.datetime(2015,1,1),datetime.datetime(2015,1,8),datetime.datetime(2015,1,30)]pd.DatetimeIndex(dates) 输出结果： 12DatetimeIndex(['2015-01-01', '2015-01-08', '2015-01-30'], dtype='datetime64[ns]', freq=None, tz=None) 如果你不仅需要时间格式统一，时间频率也要统一的话1234periodindex1 = pd.period_range('2015-01','2015-04',freq='M')print periodindex1 输出结果： 12PeriodIndex(['2015-01', '2015-02', '2015-03', '2015-04'], dtype='int64', freq='M') 月级精度和日级精度如何转换？有的公司统⼀以1号代表当月，有的公司统一以最后1天代表当⽉，转化起来很麻烦，可以asfreq 1234print periodindex1.asfreq('D',how='start')print periodindex1.asfreq('D',how='end') 输出结果： 1234PeriodIndex(['2015-01-01', '2015-02-01', '2015-03-01', '2015-04-01'], dtype='int64', freq='D')PeriodIndex(['2015-01-31', '2015-02-28', '2015-03-31', '2015-04-30'], dtype='int64', freq='D') 最后的最后，我要真正把两种频率的时间精度匹配上？12345678periodindex_mon = pd.period_range('2015-01','2015-03',freq='M').asfreq('D',how='start')periodindex_day = pd.period_range('2015-01-01','2015-03-31',freq='D')print periodindex_monprint periodindex_day 输出结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950PeriodIndex(['2015-01-01', '2015-02-01', '2015-03-01'], dtype='int64', freq='D')PeriodIndex(['2015-01-01', '2015-01-02', '2015-01-03', '2015-01-04', '2015-01-05', '2015-01-06', '2015-01-07', '2015-01-08', '2015-01-09', '2015-01-10', '2015-01-11', '2015-01-12', '2015-01-13', '2015-01-14', '2015-01-15', '2015-01-16', '2015-01-17', '2015-01-18', '2015-01-19', '2015-01-20', '2015-01-21', '2015-01-22', '2015-01-23', '2015-01-24', '2015-01-25', '2015-01-26', '2015-01-27', '2015-01-28', '2015-01-29', '2015-01-30', '2015-01-31', '2015-02-01', '2015-02-02', '2015-02-03', '2015-02-04', '2015-02-05', '2015-02-06', '2015-02-07', '2015-02-08', '2015-02-09', '2015-02-10', '2015-02-11', '2015-02-12', '2015-02-13', '2015-02-14', '2015-02-15', '2015-02-16', '2015-02-17', '2015-02-18', '2015-02-19', '2015-02-20', '2015-02-21', '2015-02-22', '2015-02-23', '2015-02-24', '2015-02-25', '2015-02-26', '2015-02-27', '2015-02-28', '2015-03-01', '2015-03-02', '2015-03-03', '2015-03-04', '2015-03-05', '2015-03-06', '2015-03-07', '2015-03-08', '2015-03-09', '2015-03-10', '2015-03-11', '2015-03-12', '2015-03-13', '2015-03-14', '2015-03-15', '2015-03-16', '2015-03-17', '2015-03-18', '2015-03-19', '2015-03-20', '2015-03-21', '2015-03-22', '2015-03-23', '2015-03-24', '2015-03-25', '2015-03-26', '2015-03-27', '2015-03-28', '2015-03-29', '2015-03-30', '2015-03-31'], dtype='int64', freq='D') 粗粒度数据＋reindex＋ffill/bfill1234full_ts = pd.Series(periodindex_mon,index=periodindex_mon).reindex(periodindex_day,method='ffill')full_ts 关于索引，⽅便的操作有？前⾯描述过了，索引有序，重复，但⼀定程度上⼜能通过key来访问，也就是说，某些集合操作都是可以⽀持的。 1234567891011121314151617181920212223242526index1 = pd.Index(['A','B','B','C','C'])index2 = pd.Index(['C','D','E','E','F'])index3 = pd.Index(['B','C','A'])print index1.append(index2)print index1.difference(index2)print index1.intersection(index2)print index1.union(index2) # Support unique-value Index wellprint index1.isin(index2)print index1.delete(2)print index1.insert(0,'K') # Not suggestedprint index3.drop('A') # Support unique-value Index wellprint index1.is_monotonic,index2.is_monotonic,index3.is_monotonicprint index1.is_unique,index2.is_unique,index3.is_unique 输出结果： 1234567891011121314151617181920Index([u'A', u'B', u'B', u'C', u'C', u'C', u'D', u'E', u'E', u'F'], dtype='object')Index([u'A', u'B'], dtype='object')Index([u'C', u'C'], dtype='object')Index([u'A', u'B', u'B', u'C', u'C', u'D', u'E', u'E', u'F'], dtype='object')[False False False True True]Index([u'A', u'B', u'C', u'C'], dtype='object')Index([u'K', u'A', u'B', u'B', u'C', u'C'], dtype='object')Index([u'B', u'C'], dtype='object')True True FalseFalse False True 大熊猫世界来去自如：Pandas的I/O老生常谈，从基础来看，我们仍然关心pandas对于与外部数据是如何交互的。 结构化数据输入输出 read_csv与to_csv 是⼀对输⼊输出的⼯具，read_csv直接返回pandas.DataFrame，⽽to_csv只要执行命令即可写文件 read_table：功能类似 read_fwf：操作fixed width file read_excel与to_excel方便的与excel交互 header 表⽰数据中是否存在列名，如果在第0行就写就写0，并且开始读数据时跳过相应的行数，不存在可以写none names 表示要用给定的列名来作为最终的列名 encoding 表⽰数据集的字符编码，通常而言一份数据为了⽅便的进⾏⽂件传输都以utf-8作为标准 这里用的是自己的一个csv数据，因为找不到参考的这个pdf中的数据。 123456cnames=['经度','纬度']taxidata2 = pd.read_csv('20140401.csv',header = 4,names=cnames,encoding='utf-8')taxidata2 全部参数的请移步API： http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html#pandas.read_csv 这里介绍一些常用的参数： 读取处理： skiprows：跳过⼀定的⾏数 nrows：仅读取⼀定的⾏数 skipfooter：尾部有固定的⾏数永不读取 skip_blank_lines：空⾏跳过 内容处理： sep/delimiter：分隔符很重要，常⻅的有逗号，空格和Tab(‘\t’) na_values：指定应该被当作na_values的数值 thousands：处理数值类型时，每千位分隔符并不统⼀ (1.234.567,89或者1,234,567.89都可能)，此时要把字符串转化为 数字需要指明千位分隔符 收尾处理： index_col：将真实的某列（列的数⺫，甚⾄列名）当作index squeeze：仅读到⼀列时，不再保存为pandas.DataFrame⽽是pandas.Series Excel … ?对于存储着极为规整数据的Excel而言，其实是没必要一定用Excel来存，尽管Pandas也十分友好的提供了I/O接口。 123456taxidata.to_excel('t0401.xlsx',encoding='utf-8')taxidata_from_excel = pd.read_excel('t0401.xlsx',header=0, encoding='utf-8')taxidata_from_excel 注意：当你的xls文件行数很多超过65536时，就会遇到错误，解决办法是将写入的格式变为xlsx。excel函数受限制问题 唯一重要的参数：sheetname=k，标志着一个excel的第k个sheet页将会被取出。（从0开始） 半结构化数据JSON：网络传输中常⽤的⼀种数据格式。 仔细看一下，实际上这就是我们平时收集到异源数据的风格是一致的： 列名不能完全匹配 key可能并不唯一 元数据被保存在数据里 1234567891011121314import jsonjson_data = [&#123;'name':'Wang','sal':50000,'job':'VP'&#125;,\ &#123;'name':'Zhang','job':'Manager','report':'VP'&#125;,\ &#123;'name':'Li','sal':5000,'report':'IT'&#125;]data_employee = pd.read_json(json.dumps(json_data))data_employee_ri = data_employee.reindex(columns=['name','job','sal','report'])data_employee_ri 输出结果： 深入Pandas数据操纵在前面部分的基础上，数据会有更多种操纵方式： 通过列名、行index来取数据，结合ix、iloc灵活的获取数据的一个子集（第一部分已经介绍） 按记录拼接（就像Union All）或者关联（join） 方便的统计函数与⾃定义函数映射 排序 缺失值处理 与Excel一样灵活的数据透视表（在第四部分更详细介绍） 数据集整合横向拼接：直接DataFrame12pd.DataFrame([np.random.rand(2),np.random.rand(2),np.random.rand(2)],columns=['C1','C2']) 横向拼接：Concatenate12pd.concat([data_employee_ri,data_employee_ri,data_employee_ri]) 输出结果 纵向拼接：Merge根据数据列关联，使用on关键字 可以指定一列或多列 可以使⽤left_on和right_on 12pd.merge(data_employee_ri,data_employee_ri,on='name') 根据index关联，可以直接使用left_index和right_index TIPS: 增加how关键字，并指定 how = ‘inner’ how = ‘left’ how = ‘right’ how = ‘outer’ 结合how，可以看到merge基本再现了SQL应有的功能，并保持代码整洁 自定义函数映射123456dataNumPy32 = np.asarray([('Japan','Tokyo',4000),('S.Korea','Seoul',1300),('China','Beijing',9100)])DF32 = pd.DataFrame(dataNumPy32,columns=['nation','capital','GDP'])DF32 map: 以相同规则将1列数据作1个映射，也就是进行相同函数的处理123456789101112131415161718192021222324def GDP_Factorize(v): fv = np.float64(v) if fv &gt; 6000.0: return 'High' elif fv &lt; 2000.0: return 'Low' else: return 'Medium'DF32['GDP_Level'] = DF32['GDP'].map(GDP_Factorize)DF32['NATION'] = DF32.nation.map(str.upper)DF32 排序 sort: 按⼀列或者多列的值进行行级排序 sort_index: 根据index⾥的取值进行排序，而且可以根据axis决定是重排行还是列 sort123456dataNumPy33 = np.asarray([('Japan','Tokyo',4000),('S.Korea','Seoul',1300),('China','Beijing',9100)])DF33 = pd.DataFrame(dataNumPy33,columns=['nation','capital','GDP'])DF33 12DF33.sort(['capital','nation'],ascending=False) ascending是降序的意思。 sort_index12DF33.sort_index(axis=1,ascending=True) 一个好用的功能：Rank12DF33.rank() 缺失数据处理 忽略缺失值：12DF34.mean(skipna=True) 不忽略缺失值的话，估计就不能计算均值了吧。 如果不想忽略缺失值的话，就需要祭出fillna了： 注：这里我在猜想，axis=1是不是就代表从行的角度呢？还是得多读书查资料呀。 “一组”大熊猫：Pandas的groupbygroupby的功能类似SQL的group by关键字： Split-Apply-Combine Split，就是按照规则分组 Apply，通过⼀定的agg函数来获得输⼊pd.Series返回⼀个值的效果 Combine，把结果收集起来 Pandas的groupby的灵活性： 分组的关键字可以来⾃于index，也可以来⾃于真实的列数据 分组规则可以通过⼀列或者多列 没有具体数据，截图看一下吧，方便日后回忆。 分组可以快速实现MapReduce的逻辑 Map: 指定分组的列标签，不同的值就会被扔到不同的分组处理 Reduce: 输入多个值，返回1个值，一般可以通过agg实现，agg能接受1个函数 参考： S1EP3_Pandas.pdf 不知道什么时候存到电脑里的资料，今天发现了它。感谢作者的资料。 本文博客地址Python数据分析入门之pandas总结基础本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[杂文-2015/12/20]]></title>
      <url>%2F2015%2F12%2F20%2Flife-20151220%2F</url>
      <content type="text"><![CDATA[今天在朋友圈，发现高中同桌q诚当上爸爸了，恭喜。虽然许久都未曾联系，但是还是由衷的内心给予祝福……回想起高中那段时光，真是记忆犹新。 那时为了一道数学难题，可以熬夜到很晚，想解法。那时为了第二天的考试，可以五点多就起床去河边晨读复习古文。那时有很多让自己感觉很用功的例子…… 可是，一切从大学就变了。虽然自己内心一直想努力，可是行动上却没有。事实很残酷，和大多数的人一样，我成为了随波逐流的人群中的一员。回想在海大的四年，多多少少有遗憾。可没有后悔药的。感慨幸运的是，遇到了一群可爱的室友。我们来自五湖四海。重庆娃娃，君。陕西娃娃，贱贱。山东娃娃，全。安徽娃娃，路路。海南娃娃，阿克。江西娃娃，耐克。 可爱的室友们，尽管现在各自奔天涯，不知道彼此都在做些什么……希望一切安好。期待重逢的那天。 上面这些书，本可以在四年里读完，可以读很多倍的数量……原本有很多时间可以自己去折腾感兴趣的技术的…… 时光易逝。 只能说过去的已经过去了。失去的都是人生。珍惜当下，努力创造未来！ 竟然从老同桌晋级为爸爸，想了这么多，其实，归结到内心，还是对自己未来的深深担忧。毕竟，不是自己一个人的人生。女朋友和我一起快五年了。我必须要加油！是的，不能让她，也不能让自己，让家人失望。 眼下的目标就是： 学好python 搞好论文 come on michael！ 晚安，世界 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python机器学习入门资料梳理]]></title>
      <url>%2F2015%2F12%2F16%2Fpython-machine-learning-list%2F</url>
      <content type="text"><![CDATA[在python基本语法入门之后，就要准备选一个研究方向了。Web是自己比较感兴趣的方向，可是，导师这边的数据处理肯定不能由我做主了。paper、peper、paper……真的挺愁人的 还有几个月就要进行春季实习招聘了，加油！总结一下python机器学习方面的资料吧。 1、数据处理1.1 综合 Scipy SciPy is a Python-based ecosystem of open-source software for mathematics, science, and engineering. In particular, these are some of the core packages这里集合着python科学计算的几乎所有核心库，也是一个导航。 Scipy Lecture Notes 极力推荐的一个学习笔记！ Scipy Tutorial scientific-python-lectures Jupyter 1.2 Numpy Numpy Tutorial Index Numpy 遇到Numpy陌生函数，查询用法，推荐！ 1.3 Pandas pandas主页 pandas主页，可以进入它的相关文档教程 pandas documents pandas史上最强参考文档集合 10 Minutes to pandas 十分钟搞定pandas 翻译版 API Reference Index Pandas 遇到陌生函数，查询用法，推荐！ pandas教程-百度经验 1.4 Matplotlib Matplotlib Gallery 提供一些图像例子 Matplotlib Tutorial(译) 翻译原文 matplotlib - 2D and 3D plotting in Python 2、数据可视化2.1 SeabornSeaborn is a Python data visualization library with an emphasis on statistical plots. The library is an excellent resource for common regression and distribution plots 2.2 Plotly Python Library 印刷品质的图片质量啊！ 3、机器算法3.1综合 用python做科学计算 五星推荐的中文学习资料！！！ scikit-learn 3.2 Cluster-聚类算法 Comparing Python Clustering Algorithms 3.3 GA(Genetic Algorithm) Pyevolve documentation 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[无法删除文件，“文件或目录损坏且无法读取”问题的解决办法]]></title>
      <url>%2F2015%2F12%2F09%2Ftools-del-error%2F</url>
      <content type="text"><![CDATA[今天下午整理我的移动硬盘上的资料，结果，删除某个文件夹出现了这样的错误： 移动硬盘出现“文件或目录损坏且无法读取”的简单修复 作为处女座的我当然不能熟视无睹！必须歼灭它~通过查资料，找到了一下解决办法。 原因首先了解下产生这个“文件或目录损坏且无法读取”问题的原因： 出现这种错误提示，是由于各种原因导致的磁盘文件目录(FAT,MFT)出错造成。主要发生在优盘、MP3、移动硬盘等移动设备上，其中大容量(160G以上)NTFS分区格式的外置移动硬盘发生几率最高最多。产生的原因很多，一般有下面几种原因： 没有正常插拔移动设备，系统没有完成完整的读写操作，致使文件目录信息错乱和不完整。比如我们复制一个文件到移动设备，关机重启、拔取后，再次打开使用或到别的电脑上使用时出现症状。 选用了劣质产品，包括劣质电源、主板、数据线、特别是劣质外置硬盘盒。产品的电源、主控电路不稳定，致使磁盘寻址出错，写信息错乱。 使用了PQ、PM等磁盘分区调整工具。 病毒、硬盘硬件本身故障、工作期间突然停电。 通过分析，我认为应该是我没有正常插拔设备造成的！ 办法命令法网上提供的办法有很多，我用其中一种方法快捷有效地解决的我的问题： 确定无法删除的文件夹或者文件所在的盘符。盘符是什么呢？如下图：盘符 使用下面的命令修复引导： 1chkdsk j: /f 格式为：CHKDSK J: /Fj: 为损坏的盘符/f 参数指修复磁盘错误更多参数说明及操作说明请运行 CHKDSK /?修复图注： cmd窗口最好以管理员权限运行。 Unlocker软件如图，菜单里有移动、删除等选项。Unlocker下载OK！大功告成！ 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git入门私房菜]]></title>
      <url>%2F2015%2F12%2F07%2Fgit-tutor%2F</url>
      <content type="text"><![CDATA[昨天下午参考廖雪峰的博客和其他一些文章，简单了解了一下传说中的Git，发现常见用法入门还是挺容易上手的，在此做一些笔记，方便以后查阅和复习。 Git安装Linuxsudo apt-get install git命令安装Git Windows官网下载 安装即可，不赘述。 注：安装时注意一步：选择第二项，将git添加到path中。 创建版本库 创建项目文件夹，例如：demo 进入demo目录下：git init命令将这个目录变成git可以管理的仓库（repository）。将仓库建好后，仓库目录下会多了一个.git隐藏文件夹。可以用ls -ah查看隐藏文件。 向库里添加一个readme.txt文件： git add告诉git，要把文件添加到仓库： 1git add readme.txt 执行命令，其实，这一步的作用就是将文件添加到stage（暂存区）。 git add .将所有文件添加到暂存区。 git add -u将所有文件添加暂存区，同时，将删除的文件从仓库中删除。 git commit命令，将文件提交到仓库。 1git commit -m "wrote a readme file" 注：-m是对本次提交的说明，不该偷懒省去。 git status查看当前版本库的状态。 git diff显示具体的尚未缓存的改动记录。 git log记录每次commit的信息。git log --pretty=oneline将每次commit的记录打印成一行，内容精简。 git reset修改命令： git reset HEAD废除这次修改记录，当前文件回到上一次提交的状态。 `git reset –hard [commit id] git rm慎用。这个命令会将所有版本库记录删除。 远程仓库创建SSH Key。在类似C:\Users\xiang_000\.ssh这样的主目录下，查看是否有id_rsa和id_rsa.pub文件。如果有了，直接可以将公钥添加到github账户上。如果没有，打开Shell(windows下的Git Bash): 1ssh-keygen -t rsa -C "youremail@example.com" id_rsa.pub是公钥，可以放心的告诉任何人。 在github的Account settings里，Add SSH Key。 从远程库克隆如果从零开发，推荐的方式是先在github上创建远程仓库。然后，从远程库克隆。 在github创建名为：learngit的新仓库。勾选添加README.md。 git clone克隆一个本地库： 1git clone git@github.com:michael728/learngit.git 添加(关联）远程库如果本地已经有本地仓库了，要和远程的仓库关联起来。在github创建新的repo，名字为：demo。根据github的提示，在本地的demo仓库下运行命令： 1git remote add origin git@github.com:michae728/demo.git` 请千万注意，把上面的michae728替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 将本地库的所有内容推送到远程库上： 1git push -u origin master 把当前本地分支master推送到远程。由于之前远程库是空的，第一次推送master分支时，加上了-u参数。git不但把本地的master分支内容推送到远程新的master分支，还会把本地master分支和远程的master分支关联起来，以后推送或者拉取就可以简化命令。 从现在起，本地提交，可通过命令： 1git push origin master 分享与更新项目git push: git push origin dev表示提交到远程的dev分支。 通常在本地的dev分支推送到远程的dev分支，注意两地分支命名要相同，保证不发生混乱 git pull: git pull origin dev表示拉远程dev分支到本地，并和本地dev分支合并 git fetch(不常用）： git fetch origin dev表示拉远程dev分支到本地，但是，不和本地dev分支合并 git remote: git remote add github git@github.com:michael728/test.git将本地仓库推送到github上名为test的仓库里 分支管理创建于合并分支创建dev分支，然后切换到dev分支： 1git checkout -b dev 相当于下面两条命令：12git branch devgit checkout dev git branch命令用于查看当前分支。当前分支前面会有*: git branch查看本地分支 git branch -a查看本地和远程所有分支 git branch -r查看远程分支 git branch -d删除本地分支 git push :origin dev删除远程dev分支 git checkout master命令用于dev分支完成工作后，切换回master分支。 git merge用于本地的指令。如果当前分支是master，本地另一个分支是dev，用下面命令将分支合并到master： 1git merge dev 后悔药版本回退git log来查询历史记录。git log --pretty=oneline显示精简信息。 git中，HEAD表示当前版本，上一个版本就是HEAD^,上上个版本HEAD^^，上100个版本，写成HEAD~100。 回到上一个版本： 1git reset --hard HEAD^ 或者通过git reset --hard [commit id]回到指定版本号的版本。 git版本的回退速度很快，因为git内部有个指向当前版本的HEAD指针。git仅仅是通过修改HEAD指向就可以完成版本切换的工作。 git reflog用来查看命令历史。通过这个，就可以查到之前的版本号啦！ 工作区和暂存区工作区（Working Directory) 例如我们创建的demo文件夹，他就是一个工作区。 版本库（Repository) 工作区有一个隐藏目录.git，这个不算工作区，它是git的版本库。 git的版本库里存了很多东西，最重要的是称为stage的暂存区，还有git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 说明： git add实际上就是把文件修改添加到暂存区； git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建爱你git版本库是，git自动为我们创建了唯一一个master分支，所以，现在git commit就是往master分支上提交更改。（因为以后还有可能往分支上提交啊！） + `git status`可以查看状态。如果有文件从来没有被添加过，那么它的状态是：`Untracked`。 + 提交成功后，如果没有对工作区做任何修改，那么工作区就是`working directory clean` 管理修改 git diff HEAD -- README.md 命令查看工作区和版本库里最新版本的区别。 撤销修改分为两种情况的修改： 修改了工作区某个文件的内容，想直接丢弃修改： 1git checkout -- filename 注：--前后都有空格。 当修改了工作区内容，同时，添加到了暂存区，分两步： 用命令git reset HEAD filename,回到场景1 用场景1的方法操作。 删除文件当删除了工作区的文件，git知道删除了文件，因此，工作区和版本库就不一致。git status命令会立刻告诉那些文件被删除了。有两个选择： 确实要从版本库里删除该文件，用命令git rm fimename,之后git commit提交。 误删，因为版本库里还有，可以很轻松的把误删的文件恢复到最新版：git checkout -- filename 注：git checkout其实是用版本库里的东西替换工作区的版本。无论工作区是修改还是删除，都可以一键还原。 附件 欢迎来我的博客：Michael翔的小窝 参考 廖雪峰git教程 21分钟入门Git 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python入门资料大全(更新ing)]]></title>
      <url>%2F2015%2F12%2F02%2Fpython-files-list%2F</url>
      <content type="text"><![CDATA[一、说明面对网络上纷繁复杂的资料，自己真是眼花缭乱，学的毫无章法，东一榔头西一棒子，这样不仅知识不能成为体系，自己的学习进度也不容易掌握，收效甚微。突然有个想法，就是把自己这几天收藏的资料整理出文章出来，方便自己有章可依…… PS:附上一些python相关的好文： 萧大的编程入门指南知乎获赞无数的编程指南，介绍的不光是一门语言的入门，也是关于编程的入门，谈到了作为一名程序员，应该掌握的一些计算机知识。 Python 编码风格指南中译版（Google SOC）PythonTab中文网二、Python社区Python Tip社区 强烈推荐Python Tip,有刷题挑战赛，同时，也有很多在线教程！练手实操必备！ 啄木鸟社区编程指南社区Co三、入门阶段介绍一些入门的资料，对于有编程经验的同学来讲，入门资料学习并不是很费力。 简明教程 入门教程里，简明教程算是细节介绍相对详细的了，知识面也覆盖的挺全，入门资料的好选择。 笨办法学python坚持看完了，尽管最后几章没去实现（主要是和我现在的需求不一致，不想花精力在那个上面）。有所收获吧，但是，确实是入门的，知识不全面，入门够用，风格特别，采用问答形式，学习过程挺有趣。 Python|Codecademy在线挑战，还没用过，貌似现在对英文资料心里还有种抵触，必须克服！！！ 实验楼python研发工程师包含了Linux/Vim/Git/SQL/Python/Django/Flask等学习课程。 老齐的零基础学Python（第二版）github版本，教程内容覆盖很全，也有实战项目介绍。 廖雪峰python2.7教程现在已经有python3的教程了。 Vamei的的python快速教程话说，我还加入了博主的粉丝群，后来加入了微信群，逗比一枚啊，现在好像去新加坡深造去了！博客文章还是很详细的~ 总结到这儿我已经有乱花渐入迷人眼的感觉了！光是入门就这么多资料，看的过来吗？看完得到猴年马月啊！所以必须痛下决心，选择自己觉得好的就OK！青菜萝卜，各有所爱，别人觉得好的，可能在你这儿就是看着不舒服！好吧，自己就选择简明，笨办法，还有，codecademy!ok,暂时就这样了！ 四、充实阶段入门之后，对于这个语言的细节需要更进一步的了解，那么提升阶段必不可少。同时，对于计算机基础不好的同学，了解计算机及编程相关背景知识也很关键。 《Python基础教程》根据自己学习javascript的经验，一本好的教材真是获益匪浅，它能让你明白很多底层的东西。比如红宝书《js高级程序设计》中关于闭包、原型链的讲解就非常详细！好吧，扯远了，因此，学习python也是一样，光是靠博客，在线文章是不能深入了解它的，选择一门经典教材是你深入了解一门语言的必经之路！当然，也有推荐《Python核心编程（第二版）》的，但是自己只买了《Python基础教程》因此，不做评价了，选中一本经典就可以了！何况自己离吃透它，还有很远的距离的！ MIT计算机科学及编程导论Harvard:计算机科学cs502和3属于计算机入门课，之所以放到这儿，是因为介绍了计算机领域中相关的知识点，了解数据结构相关知识。其中，MIT的导论课老师的知识点是基于Python的，在学习时也能巩固Python。编程入门指南中强烈推荐的的两门公开课。（PS：网易真是良心，这两门课都有中英字幕的视频！） Crossin教室除了python教程之外，还有小程序，练手很好！在第一阶段入门之后，来这里做应用小程序，会找到成就感！除此之外，还有git等其他教程。是个不错的入门练手的地方。 五、升华阶段有了扎实的基础，那么方向的选择显得尤为重要了。是数据分析，是web开发，还是游戏开发。下面暂时分为这三个方面整理一下： 5.1 数据分析利用Python进行数据分析这本书是一本大而全的利用Python数据分析的书，数据分析入门肯定够够的，写的也很详细。书的作者就是开发了用于数据分析的著名开源Python库——pandas的作者！ scientific-python-lectures英文资料，对Python数据分析中要用到的一些库，pandas,numpy,matplotlib等等做了简要介绍。Ipython Notebook形式的资料，示例代码都很全。 Matplotlib Tutorial(译)Python制图的入门资料，强烈推荐！在线版的资料，作者排版也很舒服，示例代码也有，推荐！ 5.2 web开发自强学堂Django基础教程很详细的一个Django教程，作者很详细的介绍了每一步。有问题，作者回复也很详细，推荐！同时，自强学堂上也有很多其他教程，是个不错的网站，收藏！ Django搭建简易博客教程建议和1结合看，1的介绍相对更详细一点。 欢迎进入Flask大型教程项目Flask指南#5.3 游戏开发 用Python和Pygame写游戏-从入门到精通六、 计算机素养《深入理解计算机系统》七、 Python面试题 聊聊Python面试那些事儿 暂时总结到这儿了，和大家分享一下，希望有帮助！ 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sublime常用插件及用法整理]]></title>
      <url>%2F2015%2F12%2F01%2Ftools-sublime-extensions%2F</url>
      <content type="text"><![CDATA[sublime text 必装插件挖坑，待续 Sublime Text 3设置python编译支持环境设置安装sublimerepl插件 官网说明 Preference-&gt;key bindings-user 添加快捷键123456789101112&#123; "keys": ["alt+q"], "command": "repl_open", "caption": "Python", "mnemonic": "p", "args": &#123; "type": "subprocess", "encoding": "utf8", "cmd": ["python", "-i", "-u", "$file"], "cwd": "$file_path", "syntax": "Packages/Python/Python.tmLanguage", "external_id": "python" &#125; &#125; 然后由于快捷键alt+z之后出现在旁边的一栏，通过设置view-&gt;layout-&gt;2 rows就可以显示上下两个窗口。快捷键alt+shift+8，恢复单个窗口：alt+shift+1 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo之next主题优化整理]]></title>
      <url>%2F2015%2F11%2F30%2Fhexo-next-optimize%2F</url>
      <content type="text"><![CDATA[搭建hexo的教程实在太多了，折腾了几天，总算搞定了，现在去看参考文章也是能看懂，不过，官方文档也写的相当详细： Hexo Next Yml语法验证 hexo主题 hexo-theme hexo-github-theme-list 有那些好看的hexo主题？ Next主题添加多说新建站点时会创建多说域名：创建站点完成后在 站点配置文件（不是主题配置文件）中新增 duoshuo_shortname 字段，值设置成上一步中的值。duoshuo_shortname: michael-xox其他主题主题添加多说，参考： http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9 http://dev.duoshuo.com/docs/5016427f77cf5fa30500000e hexo命令更新hexo：npm update -g hexo 更新主题：cd 到主题文件夹，执行命令：git pull 更新插件：npm update 因为重装系统的缘故，重新要配置一下环境。简要做个笔记。 Windows下npm安装Hexo失败的解放方案因为国外源网速不好的原因，安装hexo失败，可以采用如下方案：命令搞定HEXO!!!12345678# 添加淘宝源npm install -g cnpm --registry=https://registry.npm.taobao.org# nrm类似包管理器cnpm install nrm -gnrm ls# 使用淘宝nrm use taobaonpm install -g hexo-cli 大功告成！ http://www.codes51.com/itwd/1327882.htmlhttp://www.thinksaas.cn/ask/question/21934/ 安装NEXT1git clone https://github.com/iissnan/hexo-theme-next themes/next 参考：Next配置 优化头像设置编辑 站点配置文件，新增字段 avatar， 值设置成头像的链接地址。avatar: http://i5.tietuku.com/0d972d2b106fc7ea.jpg 网站logo设置 通过网站favicon在线制作制作favicon图片，logo最好设置32*32。 next主题：将图片放在next主题source/images目录下 在next主题配置文件中添加：favicon: images/favicon.ico 添加关于页面hexo new page &quot;about&quot;在source文件夹下就会有about文件夹，编辑index.md，然后进入主题的_config.yml中，menu下的#about注释去掉 添加目录云、标签云页面12hexo new page "tags"hexo new page "categories" 然后设置同上，去掉主题配置文件中的注释，调整菜单顺序 设置侧边栏头像在站点配置文件，不是主题配置文件中，添加：12avatar: url#avatar: /uploads/avatar.jpg 设置网站图标Logo 通过网站favicon在线制作制作favicon图片，logo最好设置32*32。 next主题：将图片放在next主题source/images目录下 在next主题配置文件中添加：favicon: images/favicon.ico或者把favicon.ico放到主题文件夹source文件夹下就可以了-》favicon: /favicon.ico12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/favicon.ico 增加打赏功能 hexo博客Next主题添加打赏功能 hexo next 主题添加打赏功能 实现网站的打赏功能 为Hexo博客添加版权说明和打赏功能 设置阅读次数 为NexT主题添加文章阅读量统计功能 为博客文章添加阅读量统计功能-LeanCloud 添加最近访客和多说 动动手指，NexT主题与Hexo更搭哦（基础篇） 动动手指，给你的Hexo站点添加最近访客（多说篇） SEO Hexo NexT 主题SEO优化指南 个人博客SEO实践 Hexo教程(四)-hexo博客被搜索引擎收录 Hexo+nexT主题搭建个人博客 安装sitemap扩展： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码: 12345# hexo sitemap网站地图sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 注意：这个地方的空格要符合语法规范！ 提交sitemap参考next主题官方解答：添加 Google Webmaster tools 验证 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。其次，在robots.txt中添加下面的一段代码： 12Sitemap: http://www.arao.me/sitemap.xmlSitemap: http://www.arao.me/baidusitemap.xml 参考这篇文章hexo博客被百度+google收录的方法 提交sitemap.xml 添加友链在主题配置文件 _config.yml中Sidebar Settings部分添加字段：123456# Blogrollslinks_title: 友情链接links_layout: inlinelinks_icon: link # 设置图标links: Michael翔: http://michaelxiang.me 添加搜索 安装npm install generarot-search 在站点配置文件，不是主题配置文件中，添加：1234# 添加搜索search: path: search.xml field: all 注意：需要在站点配置文件中设置：url: http://michaelxiang.me/，否则搜索的结果点击链接，会跳转到错误页面。 添加背景 参考hexo引用自定义js文件和css样式，在github资源中找到particle.js，将其下载到本地主题文件夹D:\03TBP\TBP\BLOG\themes\next\source\js\src类似这样的文件夹下。 然后在主题layout/_layout.swig中的最后body标签上添加&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt; 参考 Hexo博客优化 - Next主题个性化定制-推荐！！！ hexo下新建页面下如何放多个文章？ 玩转Hexo博客之Next 动动手指，不限于NexT主题的Hexo优化（SEO篇） 博客推广——提交搜索引擎SEO Next主题常见问题 主题配置 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo之github\gitcafe多线路托管博客，DNS域名设置]]></title>
      <url>%2F2015%2F11%2F30%2Fhexo-gitcafe-github-dns-goddaddy-set%2F</url>
      <content type="text"><![CDATA[上一篇挖坑总结（1）中已经详细讲解了同时部署到gitcafe和github上的方法了，那么，接下来要讲解的就是DNS域名相关的问题： 在goddaddy上购买域名关于goddaddy购买域名及设置的流程，就不再说了，很简单，可以参考：Godaddy优惠码网站 设置github及gitcafegithub要在博客站点source文件夹，如：E:\KP\my_blog\source下新建CNAME文件，编辑加入：michaelxiang.megithub官方参考：Categories / GitHub Pages Basics gitcafe在gitcafe的page设置，添加域名:michaelxiang.megitcafe官方参考：gitcafe关于page说明 Dnspod域名解析设置github相关想要访问michaelxiang.me是通过github访问，我们在dnspod设置完CNAME就够了。 gitcafe相关在dnspod里设置，为了让国内ip访问michaelxiang.me是通过gitcafe，我们需要设置CNAME。 说明： 这里建议用设置CNAME的方式，为了防止github或者gitcafe主机迁移导致A记录的ip也需要更改才能访问的额弊病。 gitcafe的记录值，gitcafe.io，而不是用户名+gitcafe.io,这和github不一样，归功于gitcafe提供的域名绑定功能！ 主机记录是@,没用其他的，这样设置就OK了，因为我自己用的是裸域名。Hexo多Repo部署——使用Github和GitCafe同时托管博客 线路类型，gitcafe对应的是国内,github对应的是默认，这么设置的话，那么国内ip访问就是访问的gitcafe，国外ip就是github。 如下图，可以设置监控，当有问题时，切换解析。 测试1ping michaelxiang.me 我们将会看到，它的实际访问ip，就是gitcafe.io。懂点ping方面的知识也是不错的，也算是这次搭建hexo博客的收获之一。 经过比较，发现，gitcafe的博客访问速度确实要快一点。 听过ping可以发现如果是要增加A记录的话，ip地址该写多少。通过dnspod解析域名 已发送若是大于已接收的话，就代表发生了丢包的现象 通过ping+网址\ip 地址，可以查看主机运行情况 #参考 关于CNAME介绍参考dnspod官方参考 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo之github\gitcafe多线路托管博客deploy及SSH设置问题]]></title>
      <url>%2F2015%2F11%2F30%2Fhexo-gitcafe-github-deploy%2F</url>
      <content type="text"><![CDATA[github时常抽风，访问不了，速度和国内的gitcafe相比，也稍微慢一点。那么通过将博客文件部属同时部署到这两个网站，之后通过DNS域名等设置，国内访问gitcafe，国外访问github，这样就ok啦！ 检查SSH keys的设置github官方参考文档：generating ssh keys检查电脑上现有的SSH，简单点单来说，SSH就是和秘钥有关的文件，可以看这篇《理解git,github和SSH Keys》1cd ~/.ssh 咱们要是配置过，ssh一般都在C:\Users\xiang_000\.ssh这样的文件加下。如果检查到有这样的文件，咱们如果现在是在重新搭建的话，可以把这个备份到别处，防止有用，然后把它们删除，然后重新生成。 双SSH生成通过Git bash窗口，生成新的SSH 生成github的SSH1ssh-keygen -t rsa -C "github的email“ 会看到很多需要确认的，咱们一路Enter到底。 github账户设置中添加SSH在C:\Users\xiang_000\.ssh文件夹下就有了github_rsa、github_ras.pub,用编辑器打开pub文件，将公钥添加到github accounting-&gt;add key 配置账户信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成自己的。 12git config --global user.name "github账户名，不是昵称"git config --global user.email "github邮箱名" 测试1ssh -T git@github.com 看到successfully就代表上述配置就没问题，可以正常连接到github啦！ 生成gitcafe的SSH官方的参考文档就很详细了，参考：如何同时使用多个公秘钥1ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" -f ~/.ssh/gitcafe 这样生成的gitcafe的ssh在C:\Users\xiang_000\.ssh目录下就有别名，和github生成就有区分。然后步骤差不多，将gitcafe的pub添加到gitcafe中。 Github\Gitcafe双Deploy部属双部属参考文章：hexo博客搭建时遇到的问题在 SSH 用户配置文件 ~/.ssh/config 中指定对应服务所使用的公秘钥名称(config文件的作用就是告诉git程序在同步认证的时候该使用哪个密钥），如果没有 config 文件的话就新建一个，并输入以下内容：12345678Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host gitcafe.com www.gitcafe.comIdentityFile ~/.ssh/gitcafe 注:新建config的两种方式： 新建txt文件,添加完内容之后，重命名，把txt格式名去掉。 touch config命令新建，再用编辑器打开 hexo站点deploy配置123456deploy:type: gitmessage: "xxxxx"repo:github: git@github.com:michael728/michael728.github.io.git,mastergitcafe: git@gitcafe.com:michael233/michael233.git,gitcafe-pages 注意：repo的格式要这么写，因为我们部属时，是利用的ssh方式，所以千万别写成:repo: https://github.com/michael728/michael728.github.io.git 部属，同步到gitcafe\github上12hexo cleanhexo d 关于之后的DNS域名等设置，看下一篇文章。 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[大圣归来]]></title>
      <url>%2F2015%2F11%2F29%2Fsong-wukong%2F</url>
      <content type="text"><![CDATA[这么呆萌，我要不要换头像？………………]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows上那些值得推荐的良心软件-整理]]></title>
      <url>%2F2015%2F11%2F28%2Ftools-list-win%2F</url>
      <content type="text"><![CDATA[Windows上那些值得推荐的良心软件-整理其实，Windows系统挺好用的，并不像有些程序员说的那么不堪，尽管我也一直想体验Mac，哈哈……言归正传，Win10的变化还是挺明显的，很多地方都进行了优化，个人觉得有一条技巧使用起来还是很方便的：不要管桌面有多乱，怎么方便怎么来！（强迫症患者无视……） 做法就是把常用的软件全部固定到“开始”屏幕，这样设置以后的好处就是：比如当你正在浏览器浏览网页时，想打开微信，就只要两步，按一下Win键+点击微信；如果将软件图标放在桌面的话，则需要三步，缩小你正在浏览的网页，然后切换到桌面，打开微信。很明显，你正在做的事情就被打乱了…… 工欲善其事，必先利其器！ 一-【日常工具】文件搜索 Listary 小众软件介绍，超级好用的文件搜索工具，按下快捷键，随时搜索 Everything 也是传说中的文档搜索神器！其他功能有待开发…… 聊天 TIM-QQ QQ最新推出的简洁办公版本，还不错 微信 视频播放 PotPlayer 厌烦了暴风一打开就是广告，发现了这款播放器，没广告！能力出色！ 下载神器 FDM 最近体验过的最棒的下载工具了，开源免费，无广告，虽然IDM也很强大，但是IDM要钱呀，FDM一样用！2017-04-03 EagleGet 这样好的下载神器，竟然这么默默无闻，简直没有道理啊！用它来下载百度云上的资源速度也是杠杠赞！用来替代浏览器自带下载要好很多，速度快很多！缺陷是不支持BT/磁力链接…… 硕鼠 视频下载神器！为了下载PC上的网易公开课发现的工具，很多视频网站都能下载！ 维棠播放器 之前了解过的一个视频下载软件，没有体验过，据说厉害。 浏览器 Chrome 很占内存，但启动速度、标签、扩展同步等真是做的棒！一个账号，走遍天下~安利下自己总结的Chrome扩展 Chrome下载 由于某些原因，你可能无法下载扩展，这里可以帮你下载 crx4chrome FireFox 其实火狐也是不错的，它的同步是可以用的，不像chrome那样，需要架梯子~ 解压软件 Bandizip 清新简洁，功能很强大，最喜欢它可以设置双击直接解压，无需其他操作 7zip 著名解压软件，也是免费 笔记 印象笔记 很棒！裁剪、搜索、标签等细节功能做的很到位！简洁大气的风格，很喜欢。双十一入手了一年的VIP，hia~hia~ 为知笔记 国内良心笔记公司，做的也很棒！代码高亮、Markdown等等都一应俱全，还有丰富的插件~ pdf查看 福昕pdf阅读正版 电子书查看器 calibre Ebook-Reader 看图 FastStoneImageViewer 免费软件，好用到爆！没广告！功能齐全！不光能看图，还能修图！ 输入法 搜狗 搜狗输入，跨平台性确实很好，广告什么的其实可以通过设置去除的！ rime rime输入法，跨平台的良心输入法，也没有广告！ 截图 搜狗输入法 哈哈，没看错！就是它！安装截图扩展之后，快捷键就能截图，哪个电脑都ok，多方便！我的技巧总结 snipaste 国人开发的一款截图软件，挺简洁的 picpick 确实很棒的一个截图工具，很强大，界面也很舒服 sharex 一款功能非常强大的开源软件，需要学习使用，功能确实太多了 FastStone Capture 这款需要收费，但是可以很多资源找到免费的,比如这里 togif gif动态图制作软件 邮箱 Foxmail 除了接收邮件，还有RSS订阅功能！ 加密工具 Wise Folder Hider Free 隐私文件怎么保存？这个获奖无数的工具，免费版足够用啦！ 写作工具 typora 韩国的一款Markdown写作工具，免费的，简介好用！ 1checker 英文写作，语法校对工具 思维导图 Xmind 今天体验了一下思维导图，虽然Freemind是开源免费的，但是，这款付费的显然更胜一筹啊！颜控必备！ 文件整理 Q-dir 有时候需要在文件夹之间移动文件，这时候，这个整理神器就能派上用场了！ 快速启动 MaxLauncer 最近发现的一款不错的软件，可以通过快捷键快速启动软件！ Wox 也是一个软件启动神器，但是，上次体验之后被我打入冷宫了，不知道现在怎么样，总之，值得体验！ 小众工具 Wgesture 用惯浏览器鼠标手势的同志，这个绝对是你们的福利！全局鼠标手势！！！ Ditto 剪贴板工具，效率必备，对于经常文字编辑的人员，那就是神器了！ 学术工具 NoteExpress 高校大多都购买了，既然有正版，为何还要千方百计去折腾外国的呢？挺好用~ 同步盘 百度云2016年这一年关了很多免费的网盘，貌似就百度网盘坚挺了，百度云也改名为百度网盘，百度云应该作为百度的云品牌发展了！果然免费的不会一直免费下去的！ OneDrive 买希捷的移动硬盘送的容量，就试试了，结果发现用来同步简直太爽了！！！而且，Windows基本都自带，其实体验挺好的！据说，淘宝可以买扩容量套餐微云腾讯的微云也不失为一种选择，尽管，最新的政策出来了，免费空间也降低了！ FileGee 实习时，帆哥告诉我的工具，可惜，最后没选择留在那儿，感恩吧 2016-08-08 卸载清理 RevoUninstaller卸载程序必备神器！体验了Iobit家的卸载产品之后，仍然回头来使用这款！有机会写篇文章来介绍一下。 Unlocker下载 当你重命名或删除一个文件/文件夹时,Windows 弹出对话框提示你“无法删除 xxx:它正在被其它用户/程序使用!”,怎么办? ccleaner 免费的系统清理软件 二-【系统优化】右键菜单管理 右键菜单-FileMenuTolls 这是一个神器，在右键菜单中方便提供了很多小功能，比如，文件校验功能，就能方便的验证系统镜像文件是否完整，有没有被修改。 屏保 fliqlo 数字时钟，屏幕保护，逼格满满 flux 视力保护，通过根据时间调节屏幕颜色，减少蓝光对视力的影响，效果有点类似iphone开启眼见屏幕保护色。 系统安全 火绒安全 最近发现的比较安静的安全软件，最喜欢它的窗口拦截功能，比如迅雷的那些弹窗，他都给拦截掉了！ 系统修复 PowerTool 查看系统进程等信息，安全修复！ Dism++ 知乎看到的，简洁的系统管理软件，集成了很多小工具，还可以系统备份 Dock栏 RocketDock 可以在屏幕上添加Dock栏，将常用快捷方式添加到状态栏上！有点Mac效果的感觉 三-【系统相关】安装系统准备 MSDN镜像下载 干净的系统镜像！ 清华大学开源软件镜像站 可以下载到很多Linux镜像，速度很快！ easybcd 引导工具 easyuefi 引导工具 ultraiso 制作启动盘 双系统 Windows10+Ubuntu双系统安装[多图] windows10+ubuntu 16.04+双硬盘（SSD+HDD）分区（图文） Ubuntu 16.04与Win10双系统双硬盘安装图解 有这三篇文章，基本是够了，需要注意的点是：要知道你的是UEFI+GPT还是传统的MRB！ 系统检测 AIAD64 硬件检测工具，里边功能很丰富！ 硬盘性能检测-AS SSD Benchmark CrystalDiskMark 四-【资源】软件资源 正版中国 filehippo 软件缘 大眼仔 精品绿色便携软件 软矿 殁漂遥 吾乐吧软件站 sourceforge softpedia 反斗软件 参考 Windows 10 上什么软件值得推荐？ Windows 平台有哪些值得推荐的常用软件？ 推荐-Gitbook-Windows绝赞应用 Windows下的开发工具控制台 cmder 如果厌倦了Windows下控制台丑陋不方便的样子，可以试试这个,强烈安利！这是一篇比较好的介绍文章Win下必备神器之Cmder 编辑器 Sublime Text Notepad++ Atom IDE Pycharm 这么棒的软件，学生党免费！前提是要有学校邮箱~下载链接 Redo python调试很方便，界面有点类似R-studio、 PyScripter python开发 WebStorm 最后不知道有多少小伙伴访问过这个页面，你平时是否有好用到哭的利器呢？ 如果有，请推荐给我！ 如果没有，那就试试我推荐的吧！:) 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。 打赏 有“新发现”就赏杯杯咖啡吧 :)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Michael翔私藏-Chrome扩展插件整理合集,效率提高,爽！]]></title>
      <url>%2F2015%2F11%2F26%2Fchrome-extentions%2F</url>
      <content type="text"><![CDATA[虽然Chrome浏览器是个吃内存的怪兽，但是，它却因为启动速度、调试功能等成为了程序猿的必备浏览器！今天有时间，整理一下自己最常用的一些Chrome扩展吧： 常用网页浏览非开发类扩展：##Tampermonkey推荐指数：★★★★★最近发现的神器啊，哈哈，很喜欢，利用脚本比安装扩展少用内存啊！速度还快！用法也很简单–20151202更新用法简要记录下： Greasy Fork国内油猴脚本的下载地，常用的百度网盘助手,去除贴吧列表里面的广告等脚本都有 当找到脚本之后，点击安装即可，然后在相关网站，就会有效果了。例如，在百度网盘下载页面，就会有百度助手下载按钮出现。 在相应页面点击油猴扩展，可以查看脚本，可以禁用。也可以卸载安装过的脚本。 OneTab推荐指数：★★★★★ Chrome是个吃内存的怪兽啊！有了这个神器，网页打开再多都不怕啦！必装！推荐！ 一键管理所有扩展推荐指数：★★★★★ 对于经常折腾扩展的同志们，就不用担心扩展安装多了，chrome就卡的问题！有了它，轻松管理扩展，暂时不用却又舍不得卸载的扩展，就可以左击一键禁用和启用，右击卸载。必装！ Proxy SwitchyOmega推荐指数：★★★★★ 这个就不用多说了，折腾浏览器的朋友一眼就懂！必装！ 右键搜推荐指数：★★★★ 看到扩展这么多设置选项，就知道它的功能是有多强大了！功能就是如它的扩展名一样，对于浏览网页时的图片，链接等，右键点击，提供很多扩展功能，例如： 对图片右击，可以选择去谷歌搜索相似图片|解析图片的网址|提取图片二维码 对页面右击，可以定制进入浏览器扩展程序菜单|查看内存|生成当前网址二维码更关键的是，它还支持自定义很多功能，例如，你可以设置对选中文字，进行在知乎里搜索！可以通过方法，自定义搜索引擎！必装神器！ 眼不见心不烦（新浪微博）推荐指数：★★★★★ Chrome就是满分评价，可见这扩展真是良心扩展啊！微博党的福音！在浏览器端，自己通过这个插件进行设置，可以将热门微博、会员推广等等内容窗口都给屏蔽了！还我们一个干净、舒服的微博环境！推荐！！！ LastPass: Free Password Manager推荐指数：★★★★★ LastPass,屡获殊荣的密码管理器,保存你的密码,让你安全访问任何计算机和移动设备。多平台同步，离不开的密码神器！安全可靠~ Chrono下载管理器推荐指数：★★★★ 这是个下载扩展，好用！之前在下载百度网盘文件时，点击下载，需要一堆操作，登录网盘，保存到网盘……为啥就不能直接下载呢？！直到我发现了它！点击下载就立马启动Chrome自带的下载器下载了！个人觉得离不开，必装！ 网页截图:注释&amp;批注推荐指数：★★★★ 在安装了一堆截图扩展之后，最后剩下了它，满足了截图所有的需求，截取可见网页，选择区域，整个网页，另外，还有对截图的标记。 印象笔记·剪藏推荐指数：★★★★★ 作为一名大象用户，这个扩展肯定是必装！这里必须稍微介绍一下它的使用： 收藏网页 截图 在百度，google搜索内容时，提供搜索笔记相关内容的功能，出现在搜索结果第一行 Adblock Plus推荐指数：★★★★★ 去除广告的插件，满天飞的弹窗广告相当烦人啊 Save to Pocket推荐指数：★★★★ 看到感兴趣的先收藏着，然后走哪儿都能看，因为它提供了全平台的APP，方便管理。Pocket也是手机端我必装的APP之一。 Imagus推荐指数：★★★★ 图片放大镜的功能！在体验了360浏览器、猎豹浏览器之后，特地去找的扩展！微博党的利器！这个不管能鼠标悬停放大图片，同时，对链接等也有预览。提供很多功能选项进行设置。 crxMouse Chrome Gestures推荐指数：★★★★ 对于国产浏览器自带鼠标手势的功能，真觉得很方便！这款扩展也是必装啊！ Infinity新标签页推荐指数：★★★★ 功能强大的新建标签页扩展！做的界面很美，每日壁纸质量也很高！有同步笔记、代办事项等，同时，喜欢它的网页图标，提供了很多常用网站的图标，自定义书签时很好看~唯一的缺点，就是感觉启动比较慢~ 划词翻译推荐指数：★★★ 选中英文单词，翻译。对于经常浏览英文网页的同学，是个很方便的扩展，可以进行设置：ctrl+选中单词，然后才翻译，避免不需要翻译时，弹出宽口。 惠惠购物助手推荐指数：★★★ 剁手党的神器！本来想给五星的，但是，双十一期间，竟然对淘宝不能查价了！减了两个★！还有，安装它之后，必须要进入扩展选项设置，不然这货会弹出广告！ FaWave(发微)推荐指数：★★★ 这款扩展的功能主要是支持微博在不同平台的发送~我个人主要用来提醒我未读的评论等。可惜，它有时延时很明显，提醒有点慢……有时错过领导的评论，后果是很严重的，囧 Bookmark Checker推荐指数：★★★ 对于书签收藏的狂魔同志，收藏夹里的网页肯定有很多都无法访问了吧！这款扩展就是来检测书签是否有死链的。因为不怎么常用，所以才三颗星。 VeryCD下载破解推荐指数：★★★ 之前为了搜索公开课视频，搜到电驴上有资源，但是，却不提供下载地址了……后来，我发现了这个神器VeryCD下载破解！同样，因为不经常用，所以给了三星，但是，需要时，就是神器！ 程序猿开发相关扩展：Vimium推荐指数：★★★★★ VIM党的利器吧，可惜，自己还未去掌握…… Markdown Here推荐指数：★★★★★ 这个扩展简直是Markdown的福音啊！！！在写邮件、印象|为知笔记（命名不需要.md)在线版编辑文字时,遵循Markdown语法编辑文字，然后点击Markdown Here扩展就可以可以一键渲染！渲染效果可以在该扩展选项里进行设置，多个主题可以选择！没钱入手马克飞象的同志们，可以考虑用这个神器啊！！！从此，邮件也可以回复的有逼格啦! 新浪微博图床推荐指数：★★★★★ 简单好用的新浪微博图床,支持选择/拖拽/粘贴上传图片,并生成图片地址,HTML,UBB和Markdown等格式,支持浏览和删除历史记录。 Clear Cache推荐指数：★★★★★ 点击图标即可清除缓存、cookie等，开发必备！ Code Cola推荐指数：★★★★★ Code Cola是一个可视化编辑在线页面css样式的chrome插件。 WEB前端助手(FeHelper)推荐指数：★★★★ FE助手：包括字符串编解码、图片base64编码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析等 二维码(QR码)生成器推荐指数：★★★★ 前端开发调试，生成当前网页的二维码 AlloyDesigner推荐指数：★★★★ AlloyDesigner是来自Tencent.AlloyTeam的前端开发工具，其只出现开发阶段的一定时期，可以在制作时期，也可以在开发测试期，旨在提高前端开发的效率，获得更加便捷的开发体验。AlloyDesigner的主要功能是加载Web页面的视觉稿，结合开发者工具(F12)进行页面的开发和调整。使用AlloyDesigner进行页面开发，基本上可以舍弃Photoshop进行页面的测量，以视觉稿做为背景蓝本进行开发，可以使开发体验更加便捷、高效，其结果页面也更高。AlloyDesigner也可以做为页面开发完成后，对页面进行细微调整，达到更加贴近视觉稿的目的。 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python多版本共存工具-Pyenv及Anaconda科学计算环境的配置]]></title>
      <url>%2F2015%2F11%2F26%2Fpython-pyenv-anaconda%2F</url>
      <content type="text"><![CDATA[为了安装Anaconda科学计算环境，控制好python版本，今天上午总算折腾好了。 学习python有时希望在python2.7环境下，有时希望在python3.4环境下，该怎么办呢？ Anconda的包也不知道适合在什么环境下工作？ 解决多python环境下，python版本切换的工具–pyenv应运而生。同时，另外一个工具virtualenv则提供了一种功能， 就是将一个目录建立为一个虚拟的python环境， 这样的话， 用户可以建立多个虚拟环境， 每个环境里面的python版本可以是不同的， 也可以是相同的， 而且环境之间相互独立。下面简要介绍一下安装的过程： Unix系统下pyenv安装与使用:安装pyenv12345678$ git clone https://github.com/yyuu/pyenv.git ~/.pyenv #使用 git 把 pyenv 下载到家目录$ echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.bashrc #然后需要修改环境变量，使用 Bash Shell 的输入$ echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.bashrc$ echo 'eval "$(pyenv init -)"' &gt;&gt; ~/.bashrc #最后添加 pyenv init$ exec $SHELL -l #输入命令重启 Shell,然后就可以重启pyenv 查看pyenv可安装的版本列表1$ pyenv install --list 該命令将列出pyenv可以安装的列表，单单列举几个咱们关心的python和anaconda把： 12345672.7.8 # Python 2最新版本 3.4.1 # Python 3最新版本anaconda-2.4.0 # 支持Python 2.6和2.7anaconda3-2.0.1 # 支持Python 3.3和3.4 安装指定的python版本。1$ pyenv install 3.4.1 该命令会从github上下载python的源代码安装，但是，我这里主要是用来进行科学计算的环境安装，因此，最后选择安装anaconda-2.4.0（python2.7环境） 和 anaconda3-2.4.0（python3.4环境）。可以选择都安装，之后可以使用pyenv进行版本的切换。注： 这里利用pyenv命令安装的python版本都安装在~.pyenv/versions文件夹下，当然，如果你从图形界面进入Ubuntu的用户主目录下可能看不见.pyenv文件夹，这时候，你可以使用ls -a看到隐藏的文件夹。 使用pip安装的包完成之后，可能需要对数据库进行更新:1pyenv rehash 卸载指定的python版本1pyenv uninstall x.x.x python版本查看查看当前已经安装了的python版本：1pyenv versions 输出结果如下：1234*system (set by /home/michael/.pyenv/version)2.7.13.4.1anaconda-2.4.0 system是指系统的python版本；*表示当前环境所处于的python版本 python版本切换全局版本切换：1pyenv global anaconda-2.4.0 全局切换为anaconda科学计算环境，因为，我现在也不做其他python开发，所以，无需再安装其他环境了。查看现在的python版本： 12345michael@michael-ThinkCentre-XXXX:~$ pyenv versionssystem2.7.13.4.1* anaconda-2.4.0 (set by /home/michael/.pyenv/version) 有全局版本切换，当然也会有局部环境的切换：在test文件夹下希望切换到python3.4.1:1pyenv local python3.4.1 Anaconda科学计算包的使用：使用conda list查看anaconda安装自带的包：1234567891011michael@michael-ThinkCentre-XXXX:~/test$ conda list# packages in environment at /home/michael/.pyenv/versions/anaconda-2.4.0:#abstract-rendering 0.5.1 np110py27_0 alabaster 0.7.6 py27_0 anaconda 2.4.0 np110py27_0 anaconda-client 1.1.0 py27_0 argcomplete 1.0.0 py27_1 astropy 1.0.5 np110py27_1 babel 2.1.1 py27_0 backports.ssl-match-hostname 3.4.0.2 &lt;pip&gt; 注： 使用conda list命令的环境时python版本切换到anaconda版本下，不然，这个命令无法来查询。 看上面列表就能知道，anaconda的环境下，也是能使用系统pip命令安装的包的！ 给anaconda安装包1conda install ×××× 如果需要指定包的版本。1[package-name]=x.x #指定包的版本 多个Python版本并存，尤其是2.x和3.x的并存。这个通过virtualenv可以做到。Anaconda也正是通过其实现的。下面用conda创建一个名叫python2的版本为python2.7的环境。 1conda create -n python2 python=2.7 这样就会在Anaconda安装目录下的envs目录下创建python2这个目录。向其中安装扩展可以： 直接用conda install并用-n指明安装到的环境，这里自然就是python2。像virtualenv那样，先activate，然后在虚拟环境中安装。注： 关于virtualenv的使用，还需了解，可以参考python生态 下面的操作，貌似会安装很多包，谨慎使用。 1conda create -n py34 python=3.4 anaconda 利用Pycharm的版本切换功能~推荐！很方便！可以选择安装anaconda 不同的版本，然后按照下面操作,切换版本。Windows/Linux下都有[Pycharm][1]。 打开pycharm，打开preference –&gt; project –&gt; project interpreter–&gt; Windows系统切换首先当然是安装你需要的两个不同版本的python，我安装的是2.7和3.4的，两个版本安装顺序无所谓，但是后面安装的会变成默认的（因为我是后安装的python 3.4，它就变成了默认的python）。 然后去python27 文件夹下面把python.exe改名python2.exe，然后就可以在命令行下通过python或者py来调用3.x，python2来调用2.x。 另外pip的话直接使用 pip2 或者 pip3 就可以了。 参考：pyenv Python多版本共存之pyenv yyuu/pyenv-github 用pyenv 和 virtualenv 搭建单机多版本python 虚拟开发环境 lixm/pybooklet-github 使用 pyenv 和 Miniconda 管理 Python 科学计算环境 Python 2.X 3.X 多版本共存 一篇文章入门Python生态系统 Anaconda DOWNLOAD ANACONDA NOW P]ython科学计算利器——Anaconda Python科学计算发行版—Anaconda Virtualenv(待续) https://virtualenv.pypa.io/en/latest/installation.html 本文由 Michael翔 创作，采用 知识共享署名 3.0 中国大陆许可协议 进行许可。可自由转载、引用，但需署名作者且注明文章出处。]]></content>
    </entry>

    
  
  
</search>
